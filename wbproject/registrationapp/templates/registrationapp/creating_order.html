{% load static %}

<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="{% static 'header.css' %}">
    <link rel="stylesheet" href="{% static 'zamov.css' %}">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="shortcut icon" href="{% static 'favicon.ico' %}" type="image/x-icon">  
  <style>

    #map {
      height: 400px;
      width: 600px;
    }
  </style>
</head>
<body>
    <header>
        <img src="{% static 'logo.png' %}" alt="">
        <ul>
            <li style="padding:12px 32px;"><a href="/calendar" >Календар</a></li>
            <li style="padding:12px 32px;"><a href="/planned_orders" >Доставка</a></li>
            <li style="padding:12px 32px;background:#224F55; border-radius:10px"><a href="/creating_order" style="color:white;">Створити замовлення</a></li>
            <li style="padding:12px 32px;"><a href="/warehouses">Склади</a></li>
        </ul>
        <form action="{% url 'logout' %}" method="post">
          {% csrf_token %}
          <button type="submit" class="logout">
            <img src="{% static 'logout-icon.png' %}" alt="Logout">
            <span>Вийти</span>
          </button>
        </form>
        
    </header>
    <div class="start">
      <div class="text">
        <h1 class="main_h1">Створити замовлення</h1>
      </div>
    </div>
    <section class="main_section">
      <div class="left">
        <form method="post" action="{% url 'create_order' %}">
          {% csrf_token %}
          <label for="order-name">Назва замовлення:</label>
          <input type="text" id="order_name" name="order_name"/>
          <!-- <label for="end-input">Куди:</label> -->
          <div id="destinationsContainer">
            <label>Куди:</label>
            <div class="destination-field">
              <input type="text" class="end_input" id="end_input1" name="end_input[]" placeholder=""/>
              <button type="button" class="remove-destination" style="display:none;">×</button>
            </div>
          </div>
          <button type="button" onclick="addDestinationField()" class="add-destination-btn">
            <img src="{% static 'add-goods.png' %}"> Додати адресу
          </button>
          <label for="priority">Пріоритетність (від 1 до 100):</label>
          <input type="text" id="priority" name="priority" placeholder="" />
    
                <div id="addressProductsContainer">
                    <!-- This will contain product fields for each address -->
                    <div class="address-products" data-address-id="1">
                    <label>Товари</label>
                        <div class="product-fields">
                            <div class="field">
                                <select name="options[1][]" class="options" style="width:359px" onchange="handleProductChange(this, 1)">
                                    <option value="">--- Виберіть товар ---</option>
                                    {% for product in products %}
                                    <option value="{{ product.id }}" data-amount="{{ product.amount }}">{{ product.name }} ({{ product.weight }} кг)</option>
                                    {% endfor %}
                                </select>
                                <input type="text" name="amount[1][]" placeholder="шт."/>
                                <button type="button" class="remove-product" onclick="removeProductField(this)" style="display:none;">×</button>
                            </div>
                        </div>
                        <button type="button" class="add-product-btn" onclick="addProductField(1)">
                            <img src="{% static 'add-goods.png' %}"> Додати товар
                        </button>
                    </div>
                </div>
          
            <!-- <button type="button" onclick="addFormField()" style="background: #FFFFFF;border: 1px solid #D0D0D0;box-shadow: 0px 4px 17px rgba(0, 0, 0, 0.1);border-radius: 15px;font-weight: 400;font-size: 16px;line-height: 24px;color: #7B7B7B;display: flex;align-items: center;justify-content: space-evenly;height: 57px;cursor: pointer;    width: 200px;"><img src="{% static 'add-goods.png' %}">
Додати товар</button> -->
            <label for="start-input">Звідки:</label>
            <input type="hidden" id="warehouse_id" name="warehouse_id">
            <div id="warehouses-display">
                <!-- Warehouses will be added here dynamically -->
            </div>
            <label for="planned-date">Плановий початок доставки:</label>
            <div style="display: flex; align-items: center; gap: 10px;">
    <input type="datetime-local" id="planned_date" name="planned_date" required 
           onchange="updatePlannedDateDisplay()" style="width: 200px;">
    <span id="planned_date_display" style="font-size: 16px;"></span>
</div>

            <label for="estimated-end">Орієнтовне завершення:</label>
            <input type="text" id="estimated-end" readonly>
            <input type="datetime-local" class="estimated_date" id="estimated_date" name="estimated_date" style="display: none;" readonly>
            <div id="save">
              <button type="submit">Запланувати</button>
          </div>

        </div>
        <div class="right">
            <div id="map"></div>
            <div id="map_info">
                <div id="top">
                    <p>Дистанція</p>
                    <p style="padding-right: 54px;">Час</p>
                    <p style="padding-right: 26px;">Машина</p>
                    <p>Сума</p>
                </div>
                <div id="bottom">
                    <div id="msg"></div>
                    <div id="time"></div>
                    <div id="cars-container"></div>
                    <div id="fuel"></div>
                    <input type="hidden" name="vehicle_name" id="vehicle_name">
                    <input type="hidden" name="vehicle_capacity" id="vehicle_capacity">
                    <input type="hidden" name="vehicle_fuel_amount" id="vehicle_fuel_amount">
                </div>
            </div>
          </form>
        </form>
            <br />
        </div>
    
<script>

let warehouseMarkers = [];
let destinationMarkers = [];
let destinationAutocompletes = [];
var map;
var mk1; 
var directionsService;
var directionsRenderer;
var geocoder;

function initMap() {
    const center = { lat: 48.3794, lng: 31.1656 };
    const styles = [
        {
            featureType: 'all',
            elementType: 'labels',
            stylers: [{}]
        }
    ];
    const options = {
        zoom: 5.5555,
        scaleControl: true,
        center: center,
        styles: styles,
        disableDefaultUI: true
    };

    map = new google.maps.Map(document.getElementById('map'), options);
    const trafficLayer = new google.maps.TrafficLayer();
    trafficLayer.setMap(map);

    // Warehouse marker (start point)
    const warehouseMarkerStyle = {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 8,
        fillColor: '#224F55',
        fillOpacity: 1,
        strokeWeight: 2,
        strokeColor: '#FFFFFF'
    };

    mk1 = new google.maps.Marker({ 
        map: map,
        icon: warehouseMarkerStyle
    });

    directionsService = new google.maps.DirectionsService();
    directionsRenderer = new google.maps.DirectionsRenderer({
        suppressMarkers: true, // We'll use our own markers
        polylineOptions: {
            strokeColor: '#224F55',
            strokeOpacity: 0.8,
            strokeWeight: 4
        }
    });
    directionsRenderer.setMap(map);

    geocoder = new google.maps.Geocoder();

    // Warehouse location input
    const startInput = document.getElementById('start_input');
    const startAutocomplete = new google.maps.places.Autocomplete(startInput);
    startAutocomplete.addListener('place_changed', function () {
        const place = startAutocomplete.getPlace();
        if (!place.geometry) return;
        const location = place.geometry.location;
        mk1.setPosition(location);
        map.panTo(location);
        calculateAndDisplayRoute();
    });

    // Initialize with first destination marker
    const initialMarker = new google.maps.Marker({ 
        map: map,
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 6,
            fillColor: '#FF0000',
            fillOpacity: 1,
            strokeWeight: 1
        }
    });
    destinationMarkers.push(initialMarker);
    
    // Initialize first destination autocomplete
    const endInput1 = document.getElementById('end_input1');
    const endAutocomplete = new google.maps.places.Autocomplete(endInput1);
    endAutocomplete.addListener('place_changed', function() {
        const place = this.getPlace();
        if (!place.geometry) return;
        updateDestination(0, place.geometry.location);

                // Update the first product field label
        const firstProductLabel = document.querySelector('.address-products label');
        if (firstProductLabel && place.formatted_address) {
            firstProductLabel.textContent = `Товари для ${place.formatted_address}`;
        }
    });
    destinationAutocompletes.push(endAutocomplete);

        // Add manual input listeners for the first address
    endInput1.addEventListener('input', function() {
        const firstProductLabel = document.querySelector('.address-products label');
        if (firstProductLabel && this.value) {
            firstProductLabel.textContent = `Товари для ${this.value}`;
        }
    });

    endInput1.addEventListener('click', function() {
        const firstProductLabel = document.querySelector('.address-products label');
        if (firstProductLabel && this.value) {
            firstProductLabel.textContent = `Товари для ${this.value}`;
        }
    });

    endInput1.addEventListener('blur', function() {
        const firstProductLabel = document.querySelector('.address-products label');
        if (firstProductLabel && this.value) {
            firstProductLabel.textContent = `Товари для ${this.value}`;
        }
    });

    // Listen for input changes to manually trigger geocoding
    startInput.addEventListener('input', function () {
        const input = this.value;
        if (input) {
            geocoder.geocode({ address: input }, function (results, status) {
                if (status === 'OK' && results[0]) {
                    const location = results[0].geometry.location;
                    mk1.setPosition(location);
                    map.panTo(location);
                    calculateAndDisplayRoute();
                }
            });
        }
    });
}

        // Modified addDestinationField function
function addDestinationField() {
    const container = document.getElementById('destinationsContainer');
    const count = destinationMarkers.length + 1;
    
    // Create new address field
    const newField = document.createElement('div');
    newField.className = 'destination-field';
    
    // Create new input
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.className = 'end_input';
    newInput.id = `end_input${count}`;
    newInput.name = 'end_input[]';
    newInput.placeholder = '';
    
    // Create remove button
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'remove-destination';
    removeBtn.innerHTML = '×';
    removeBtn.onclick = function() {
        removeDestinationField(this, count-1);
    };
    
    // Append elements
    newField.appendChild(newInput);
    newField.appendChild(removeBtn);
    container.appendChild(newField);
    
    // Initialize autocomplete
    const autocomplete = new google.maps.places.Autocomplete(newInput);
    autocomplete.addListener('place_changed', function() {
        const place = this.getPlace();
        if (!place.geometry) return;
        updateDestination(count-1, place.geometry.location);
        
        // Update the corresponding product label
        const productLabel = document.querySelector(`.address-products[data-address-id="${count}"] label`);
        if (productLabel && place.formatted_address) {
            productLabel.textContent = `Товари для ${place.formatted_address}`;
        }
    });
    destinationAutocompletes.push(autocomplete);
    
    // Add new marker
    const newMarker = new google.maps.Marker({
        map: map,
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 6,
            fillColor: '#FF0000',
            fillOpacity: 1,
            strokeWeight: 1
        }
    });
    destinationMarkers.push(newMarker);
    
    // Show remove buttons on all but first
    const removeButtons = document.querySelectorAll('.remove-destination');
    if (removeButtons.length > 1) {
        removeButtons.forEach(btn => btn.style.display = 'inline-block');
    }

    // Add product fields for this new address
    addProductFieldsForAddress(count);
    
    // Focus on the new input field
    newInput.focus();
}

        
        // Function to add product fields for a new address
function addProductFieldsForAddress(addressId) {
    const container = document.getElementById('addressProductsContainer');
    
    // Get the corresponding address input
    const addressInput = document.getElementById(`end_input${addressId}`);
    const initialAddressValue = addressInput ? addressInput.value : `адреси ${addressId}`;
    
    const addressProductsDiv = document.createElement('div');
    addressProductsDiv.className = 'address-products';
    addressProductsDiv.setAttribute('data-address-id', addressId);
    
    const label = document.createElement('label');
    label.textContent = `Товари`;
    
    const productFieldsDiv = document.createElement('div');
    productFieldsDiv.className = 'product-fields';
    
    const firstField = document.createElement('div');
    firstField.className = 'field';
    firstField.innerHTML = `
        <select name="options[${addressId}][]" class="options" style="width:359px" onchange="handleProductChange(this, ${addressId})">
            <option value="">--- Виберіть товар ---</option>
            {% for product in products %}
            <option value="{{ product.id }}" data-amount="{{ product.amount }}">{{ product.name }} ({{ product.weight }} кг)</option>
            {% endfor %}
        </select>
        <input type="text" name="amount[${addressId}][]" placeholder="шт." />
        <button type="button" class="remove-product" onclick="removeProductField(this)" style="display:none;">×</button>
    `;
    
    productFieldsDiv.appendChild(firstField);
    
    const addButton = document.createElement('button');
    addButton.type = 'button';
    addButton.className = 'add-product-btn';
    addButton.innerHTML = `<img src="{% static 'add-goods.png' %}"> Додати товар`;
    addButton.onclick = function() { addProductField(addressId); };
    
    addressProductsDiv.appendChild(label);
    addressProductsDiv.appendChild(productFieldsDiv);
    addressProductsDiv.appendChild(addButton);
    
    container.appendChild(addressProductsDiv);
    
    // Add event listeners to update the label when address changes
    if (addressInput) {
        // For Google Places Autocomplete
        const autocomplete = destinationAutocompletes[addressId - 1];
        if (autocomplete) {
            autocomplete.addListener('place_changed', function() {
                const place = autocomplete.getPlace();
                if (place && place.formatted_address) {
                    label.textContent = `Товари для ${place.formatted_address}`;
                }
            });
        }
        
        // For manual input changes
        addressInput.addEventListener('input', function() {
            if (this.value) {
                label.textContent = `Товари для ${this.value}`;
            }
        });
        
        // For click events
        addressInput.addEventListener('click', function() {
            if (this.value) {
                label.textContent = `Товари для ${this.value}`;
            }
        });
        
        // For blur events (when focus leaves the field)
        addressInput.addEventListener('blur', function() {
            if (this.value) {
                label.textContent = `Товари для ${this.value}`;
            }
        });
    }
        setupAmountFieldListeners();
    handleAmountChange()
}

// Function to add a product field to a specific address
function addProductField(addressId) {
    const addressProducts = document.querySelector(`.address-products[data-address-id="${addressId}"]`);
    if (!addressProducts) return;
    
    const productFields = addressProducts.querySelector('.product-fields');
    const fieldCount = productFields.querySelectorAll('.field').length + 1;
    
    const newField = document.createElement('div');
    newField.className = 'field';
    newField.innerHTML = `
        <select name="options[${addressId}][]" class="options" style="width:359px" onchange="handleProductChange(this, ${addressId})">
            <option value="">--- Виберіть товар ---</option>
            {% for product in products %}
            <option value="{{ product.id }}" data-amount="{{ product.amount }}">{{ product.name }} ({{ product.weight }} кг)</option>
            {% endfor %}
        </select>
        <input type="text" name="amount[${addressId}][]" placeholder="шт." />
        <button type="button" class="remove-product" onclick="removeProductField(this)">×</button>
    `;
    
    productFields.appendChild(newField);
    
    updateAvailableQuantities();
    setupAmountFieldListeners();
    handleAmountChange()
    
    // Show remove buttons on all product fields
    const removeButtons = productFields.querySelectorAll('.remove-product');
    removeButtons.forEach(btn => btn.style.display = 'inline-block');
}

// Function to remove a product field
function removeProductField(button) {
    const field = button.closest('.field');
    const productFields = field.parentElement;
    
    field.remove();
    
    // Hide remove buttons if only one product field remains
    const remainingFields = productFields.querySelectorAll('.field');
    if (remainingFields.length <= 1) {
        productFields.querySelector('.remove-product').style.display = 'none';
    }

    updateAvailableQuantities();
    updateWarehousesDisplay();
    setupAmountFieldListeners();
    handleAmountChange()

    //calculateAndDisplayRoute();
  }

function removeDestinationField(button, index) {
    const field = button.parentNode;
    field.parentNode.removeChild(field);
    
    // Remove marker and autocomplete
    destinationMarkers[index].setMap(null);
    destinationMarkers.splice(index, 1);
    destinationAutocompletes.splice(index, 1);

    //calculateAndDisplayRoute();
    
    // Remove corresponding product fields
    const addressId = index + 1; // Address IDs start from 1
    const productFields = document.querySelector(`.address-products[data-address-id="${addressId}"]`);
    if (productFields) {
        productFields.remove();
    }

    updateWarehousesDisplay();
    
    setupAmountFieldListeners();
    
    handleAmountChange()
    
    // Hide remove button if only one left
    if (fields.length <= 1) {
        document.querySelector('.remove-destination').style.display = 'none';
    }
}

function updateDestination(index, location) {
    if (!location) {
        const input = document.getElementById(`end_input${index+1}`);
        if (input.value) {
            geocoder.geocode({ address: input.value }, function(results, status) {
                if (status === 'OK' && results[0]) {
                    destinationMarkers[index].setPosition(results[0].geometry.location);
                    calculateAndDisplayRoute();
                }
            });
        }
        return;
    }
    
    destinationMarkers[index].setPosition(location);
    calculateAndDisplayRoute();
}

let fieldCounter = 0;

function addFormField() {
    const fieldCounter = document.getElementsByClassName('field').length + 1;

    const newField = document.createElement('div');
    newField.classList.add('field');
    newField.setAttribute('id', `field${fieldCounter}`);

    const newSelect = document.getElementById('productSelect1').cloneNode(true);
    newSelect.id = `productSelect${fieldCounter}`;
    newSelect.setAttribute('onchange', `handleProductChange(${fieldCounter})`);

    const newAmountInput = document.createElement('input');
    newAmountInput.type = 'text';
    newAmountInput.id = `amount${fieldCounter}`;
    newAmountInput.name = 'amount[]';
    newAmountInput.placeholder = 'шт.';

    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.id = 'remove_tovar';
    removeButton.className = 'remove-vehicle';

    const removeButtonImage = document.createElement('img');
    removeButtonImage.src = "../static/cross-circle.png";
    removeButtonImage.alt = "Видалити товар (Delete Product)";
    removeButton.appendChild(removeButtonImage);

    removeButton.addEventListener('click', function () {
        newField.remove();
        //updateWarehousesDisplay();
    });

    newField.appendChild(newSelect);
    newField.appendChild(newAmountInput);
    newField.appendChild(removeButton);

    document.getElementById('fieldsContainer').appendChild(newField);
}
</script>
<script
  async
  defer
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBM-PRyNaufp81rqWGvvM_6uCjhzKwj3bA&libraries=places&callback=initMap"
></script>
<script>
  
        // Modified handleProductChange function
        function handleProductChange(selectElement, addressId) {
            const selectedProductId = selectElement.value;
            const selectedOption = selectElement.options[selectElement.selectedIndex];
            const productAmount = selectedOption.getAttribute('data-amount');

                // Update the amount input placeholder
                const amountInput = selectElement.parentElement.querySelector('input[type="text"]');
                const totalAvailable = parseInt(selectedOption.dataset.amount) || 0;
                amountInput.placeholder = `${totalAvailable} шт. доступно`;
                amountInput.dataset.available = totalAvailable;
                
                // Update all quantities
                updateAvailableQuantities();

            fetch(`/api/warehouses/${selectedProductId}`)
                .then(response => response.json())
                .then(data => {
                    if (data) {
                        const amountInput = selectElement.parentElement.querySelector('input[type="text"]');
                        amountInput.placeholder = productAmount ? `${productAmount} шт.` : 'шт.';

                        // Store warehouse info with the product field
                        const warehouseInfo = document.createElement('div');
                        warehouseInfo.className = 'warehouse-info';
                        warehouseInfo.innerHTML = `
                            <input type="hidden" class="product-warehouse" data-product-id="${selectedProductId}" 
                                   value="${data.id}" data-location="${data.location}" data-name="${data.name}">
                        `;
                        
                        // Remove previous warehouse info if exists
                        const existingInfo = selectElement.parentNode.querySelector('.warehouse-info');
                        if (existingInfo) {
                            existingInfo.remove();
                        }
                        
                        selectElement.parentNode.appendChild(warehouseInfo);

                        // Update the warehouses display
                        updateWarehousesDisplay();
                    }
                })
                .catch(error => console.error(error));
        }

function updateWarehousesDisplay() {
    console.log('updateWarehousesDisplay')
    const warehouseInputs = document.querySelectorAll('.product-warehouse');
    const uniqueWarehouses = new Map();
    const warehousesDisplay = document.getElementById('warehouses-display');
    
    // Clear previous display
    warehousesDisplay.innerHTML = '';
    
    // Collect unique warehouses
    warehouseInputs.forEach(input => {
        const warehouseId = input.value;
        if (!uniqueWarehouses.has(warehouseId)) {
            uniqueWarehouses.set(warehouseId, {
                id: warehouseId,
                name: input.dataset.name,
                location: input.dataset.location
            });
        }
    });

    // Update hidden field with comma-separated IDs
    document.getElementById('warehouse_id').value = Array.from(uniqueWarehouses.keys()).join(',');

    // Create display rows for each warehouse
    uniqueWarehouses.forEach((warehouse, id) => {
        const warehouseRow = document.createElement('div');
        warehouseRow.className = 'warehouse-row';
        warehouseRow.innerHTML = `
            <input type="text" value="${warehouse.name}" readonly class="warehouse-name">
            <input type="text" value="${warehouse.location}" readonly class="warehouse-location">
        `;
        warehousesDisplay.appendChild(warehouseRow);
    });
    console.log(uniqueWarehouses);
    // Update map with first warehouse location if available
    if (uniqueWarehouses.size > 0) {
        const firstWarehouse = uniqueWarehouses.values().next().value;
        console.log(firstWarehouse.location);
        triggerGeocodeAndDisplayMap(firstWarehouse.location);
    }   
}

function triggerGeocodeAndDisplayMap(address) {
    if (address) {
        geocoder.geocode({ address: address }, function (results, status) {
            if (status === 'OK' && results[0]) {
                const location = results[0].geometry.location;
                mk1.setPosition(location);
                map.panTo(location);
                calculateAndDisplayRoute();
            }
        });
    }
}

document.addEventListener('DOMContentLoaded', function () {
    setupAmountFieldListeners();
    //handleProductChange(1);

});


function calculateTotalWeight() {
    let totalWeight = 0;
    
    // Get all product fields from all addresses
    const productFields = document.querySelectorAll('.address-products .field');
    
    productFields.forEach(field => {
        // Get the selected product option
        const select = field.querySelector('select.options');
        if (!select) return;
        
        const selectedOption = select.options[select.selectedIndex];
        if (!selectedOption || selectedOption.value === "") return;
        
        // Get the weight from the option text (format: "Name (X kg)")
        const weightText = selectedOption.textContent;
        const weightMatch = weightText.match(/\((\d+\.?\d*)\s*кг\)/);
        if (!weightMatch) return;
        
        const weightPerItem = parseFloat(weightMatch[1]);
        
        // Get the quantity input
        const quantityInput = field.querySelector('input[type="text"]');
        if (!quantityInput) return;
        
        const quantity = parseInt(quantityInput.value) || 0;
        
        // Add to total weight
        totalWeight += weightPerItem * quantity;
    });
    
    console.log('Total weight calculated:', totalWeight);
    return totalWeight;
}

function setupAmountFieldListeners() {
    // Get all amount inputs
    const amountInputs = document.querySelectorAll('.address-products input[type="text"][name^="amount"]');
    
    amountInputs.forEach(input => {
        // Remove any existing listeners to avoid duplicates
        //input.removeEventListener('input', handleAmountChange);
        // Add new listener
        input.addEventListener('input', handleAmountChange);
        calculateAndDisplayRoute();
    });
}

function handleAmountChange() {
    updateAvailableQuantities();
    const totalWeight = calculateTotalWeight();
    calculateAndDisplayRoute();
    // You can display this somewhere or use it for other calculations
    // For example, update a hidden field or display element:
    document.getElementById('total-weight-display').textContent = `${totalWeight} кг`;
}


// document.getElementById('start_input').addEventListener('input', function () {
//     if (this.value.trim() !== '') {
//         calculateAndDisplayRoute();
//     }
// });

// document.getElementById('end_input').addEventListener('input', function () {
//     if (this.value.trim() !== '') {
//         calculateAndDisplayRoute();
//     }
// });

const dateTimeInput = document.getElementById('planned_date');

// document.getElementById('planned_date').addEventListener('change', function() {
//     console.log('Selected date/time:');
//     if (directionsRenderer.getDirections()) {
//         const route = directionsRenderer.getDirections().routes[0];
//         let totalDuration = 0;
//         route.legs.forEach(leg => {
//             totalDuration += leg.duration.value;
//         });
//         updateEstimatedEndTime(totalDuration);
//     }
// });

window.onload = function() {
    let date = document.getElementById('planned_date');
    date.addEventListener('change', function() {
        console.log('date change');
        calculateAndDisplayRoute()
    });
}

function findOptimalWarehouseOrder(warehouses, startLocation) {
    // Simple approach: sort by distance from start location
    // For a more robust solution, you might want to implement a proper TSP algorithm
    return warehouses.sort((a, b) => {
        const distA = google.maps.geometry.spherical.computeDistanceBetween(
            startLocation, 
            new google.maps.LatLng(a.lat, a.lng)
        );
        const distB = google.maps.geometry.spherical.computeDistanceBetween(
            startLocation, 
            new google.maps.LatLng(b.lat, b.lng)
        );
        return distA - distB;
    });
}

// Modified calculateAndDisplayRoute function
function calculateAndDisplayRoute() {
    const startLocation = mk1.getPosition();
    if (!startLocation) return;

    // Get all warehouse locations from hidden inputs
    const warehouseInputs = document.querySelectorAll('.product-warehouse');
    const uniqueWarehouses = new Map();
    
    warehouseInputs.forEach(input => {
        const location = input.dataset.location;
        if (location && !uniqueWarehouses.has(input.value)) {
            // Geocode warehouse locations if not already done
            geocoder.geocode({ address: location }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    uniqueWarehouses.set(input.value, {
                        id: input.value,
                        name: input.dataset.name,
                        location: results[0].geometry.location,
                        lat: results[0].geometry.location.lat(),
                        lng: results[0].geometry.location.lng()
                    });
                    
                    // When all warehouses are geocoded, proceed with route calculation
                    if (uniqueWarehouses.size === warehouseInputs.length) {
                        calculateFullRoute(Array.from(uniqueWarehouses.values()), startLocation);
                    }
                }
            });
        }
    });

    // If no warehouses (shouldn't happen), just calculate with destinations
    if (uniqueWarehouses.size === 0) {
        calculateFullRoute([], startLocation);
    }
}

function calculateFullRoute(warehouses, startLocation) {

    // Collect all destination positions
    const destinations = [];
    for (let i = 0; i < destinationMarkers.length; i++) {
        const position = destinationMarkers[i].getPosition();
        if (position) {
            destinations.push({
                position: position,
                id: i
            });
        }
    }

    // Determine optimal warehouse order
    const optimalWarehouses = findOptimalWarehouseOrder(warehouses, startLocation);
    
    // Prepare waypoints - all warehouses except first (start) and all destinations except last
    const waypoints = [];
    
    // Add other warehouses as waypoints
    if (optimalWarehouses.length > 1) {
        for (let i = 1; i < optimalWarehouses.length; i++) {
            waypoints.push({
                location: optimalWarehouses[i].location,
                stopover: true
            });
        }
    }

    destinations.sort((a, b) => {
        const distA = google.maps.geometry.spherical.computeDistanceBetween(startLocation, a.position);
        const distB = google.maps.geometry.spherical.computeDistanceBetween(startLocation, b.position);
        return distA - distB;
    });
    
    // Add all destinations except last as waypoints
    if (destinations.length > 1) {
        for (let i = 0; i < destinations.length - 1; i++) {
            waypoints.push({
                location: destinations[i].position,
                stopover: true
            });
        }
    }

    displayWarehouseMarkers(optimalWarehouses)

    // Final destination is last delivery point
    const finalDestination = destinations[destinations.length - 1].position;

    const route = {
        origin: startLocation,
        destination: finalDestination,
        waypoints: waypoints,
        travelMode: 'DRIVING',
        optimizeWaypoints: true, // Let Google optimize the order of waypoints
        provideRouteAlternatives: false
    };

    directionsService.route(route, function(response, status) {
        if (status !== 'OK') {
            console.error('Directions request failed:', status);
            document.getElementById('msg').innerHTML = 'Помилка маршруту';
            document.getElementById('time').innerHTML = '--';
            return;
        }

        directionsRenderer.setDirections(response);
        updateRouteInfo(response);
    });
}

function displayWarehouseMarkers(warehouses) {
    // Remove old markers
    warehouseMarkers.forEach(marker => marker.setMap(null));
    warehouseMarkers = [];

    // Add new markers
    warehouses.forEach((warehouse) => {
        const marker = new google.maps.Marker({
            position: warehouse.location,
            map: map,
            icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: '#224F55',
            fillOpacity: 1,
            strokeWeight: 2,
            strokeColor: '#FFFFFF'
        }
        });
        warehouseMarkers.push(marker);
    });
}

function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    let result = '';
    if (hours > 0) result += hours + ' год. ';
    result += minutes + ' хв.';
    return result;
}

function updatePlannedDateDisplay() {
    const startDateInput = document.getElementById('planned_date');
    const displayElement = document.getElementById('planned_date_display');
    
    if (!startDateInput.value) {
        displayElement.textContent = '';
        return;
    }
    
    const startDate = new Date(startDateInput.value);
    const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    };
    
    displayElement.textContent = startDate.toLocaleDateString('uk-UA', options);
}

function updateEstimatedEndTime(durationSeconds) {
    const startDateInput = document.getElementById('planned_date');
    const estimatedEndInput = document.getElementById('estimated-end');
    const estimatedDateInput = document.getElementById('estimated_date');
    
    if (!startDateInput.value) {
        estimatedEndInput.value = 'Вкажіть дату початку';
        estimatedDateInput.value = '';
        return;
    }
    
    const startDate = new Date(startDateInput.value);
    const endDate = new Date(startDate.getTime() + durationSeconds * 1000);
    
    // Format for human-readable display (estimated-end)
    const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    };
    estimatedEndInput.value = endDate.toLocaleDateString('uk-UA', options);
    
    // Format for datetime-local input (estimated_date)
    const isoString = endDate.toISOString();
    estimatedDateInput.value = isoString.substring(0, isoString.length - 1); // Remove 'Z' at the end
}

function updateRouteInfo(response) {
    const route = response.routes[0];
    let totalDistance = 0;
    let totalDuration = 0;
    
    route.legs.forEach(leg => {
        totalDistance += leg.distance.value;
        totalDuration += leg.duration.value;
    });

    routeDuration = totalDuration;

    // Update UI
    mapInfo = document.getElementById('map_info');
    mapInfo.style.display = 'flex';
    document.getElementById('msg').innerHTML = (totalDistance / 1000).toFixed(1) + ' км';
    document.getElementById('time').innerHTML = formatDuration(totalDuration);
    updateEstimatedEndTime(totalDuration);

    // Calculate vehicle and fuel costs
    const warehouseIds = document.getElementById("warehouse_id").value.split(',');
    const totalWeight = calculateTotalWeight();
    
    if (warehouseIds.length > 0 && totalWeight) {
        // Fetch vehicles from all warehouses
        Promise.all([
            fetch('/api/fuel-prices/')
                .then(response => response.json())
                .catch(error => {
                    console.error('Error fetching fuel prices:', error);
                    return { prices: { 'A-95': 55 } }; // Fallback price if API fails
                }),
            ...warehouseIds.map(id => 
                fetch(`/api/vehicle/${id.trim()}`)
                    .then(response => response.json())
                    .catch(error => {
                        console.error(`Error fetching vehicles for warehouse ${id}:`, error);
                        return [];
                    })
            )
        ])
        .then(([fuelPrices, ...warehouseVehicles]) => {
            // Combine all vehicles from all warehouses
            const allVehicles = warehouseVehicles.flat();
            const distanceKm = totalDistance / 1000;
            
            // Get A-95 price (with fallback to default 55 if not available)
            const fuelPriceMap = {
                'Бензин А-95 преміум': fuelPrices.prices?.['A-95 преміум'] || 58.70,
                'Бензин А-95': fuelPrices.prices?.['A-95'] || 54.47,
                'Бензин А-92': fuelPrices.prices?.['A-92'] || 51.95,
                'Дизельне паливо': fuelPrices.prices?.['Дизельне паливо'] || 52.61,
                'Газ автомобільний': fuelPrices.prices?.['Газ автомобільний'] || 34.90
            };
            
            if (allVehicles.length > 0) {

                const vehiclesWithEfficiency = allVehicles.map(vehicle => {
                    const fuelPrice = fuelPriceMap[vehicle.fuel_type] || 54.47; // Default to A-95 price
                    const efficiency = (vehicle.fuel_amount * fuelPrice / 100);
                    return {
                        ...vehicle,
                        efficiency,
                        fuelPrice
                    };
                });

                // Sort vehicles by fuel efficiency (fuel_amount ascending) and then by capacity (descending)
                const sortedVehicles = vehiclesWithEfficiency.sort((a, b) => {
                    if (a.efficiency === b.efficiency) {
                        return b.capacity - a.capacity;
                    }
                    return a.efficiency - b.efficiency;
                });

                let remainingWeight = totalWeight;
                const selectedVehicles = [];
                
                // First try to find a single vehicle that can handle the entire load
                // and is the most fuel efficient
                for (const vehicle of sortedVehicles) {
                    if (vehicle.capacity >= remainingWeight) {
                        selectedVehicles.push({
                            ...vehicle,
                            actual_load: remainingWeight
                        });
                        remainingWeight = 0;
                        break;
                    }
                }
                
                // If no single vehicle can handle the load, use combination of different vehicles
                if (remainingWeight > 0) {
                    // Make a copy of the sorted vehicles array
                    const availableVehicles = [...sortedVehicles];
                    
                    if (remainingWeight > 0) {
                        let bestTwoVehicleCombo = null;
                        let bestTwoFuelCost = Infinity;
                        const distanceKm = totalDistance / 1000;

                        let bestThreeVehicleCombo = null;
                        let bestThreeFuelCost = Infinity;

                        // Try all 2-vehicle combinations
                        for (let i = 0; i < sortedVehicles.length; i++) {
                            for (let j = i + 1; j < sortedVehicles.length; j++) {
                                const v1 = sortedVehicles[i];
                                const v2 = sortedVehicles[j];
                                const totalCapacity = parseFloat(v1.capacity) + parseFloat(v2.capacity);

                                if (totalCapacity >= totalWeight) {
                                    // Compute total fuel cost for this pair
                                    const costV1 = (v1.fuel_amount * v1.fuelPrice / 100) * distanceKm;
                                    const costV2 = (v2.fuel_amount * v2.fuelPrice / 100) * distanceKm;
                                    const totalFuelCost = costV1 + costV2;

                                    if (totalFuelCost < bestTwoFuelCost) {
                                        bestTwoFuelCost = totalFuelCost;
                                        bestTwoVehicleCombo = [v1, v2];
                                    }
                                }
                            }
                        }

                        // Try all 3-vehicle combinations
                        for (let i = 0; i < sortedVehicles.length; i++) {
                            for (let j = i + 1; j < sortedVehicles.length; j++) {
                                for (let k = j + 1; k < sortedVehicles.length; k++) {
                                    const v1 = sortedVehicles[i];
                                    const v2 = sortedVehicles[j];
                                    const v3 = sortedVehicles[k];
                                    const totalCapacity = parseFloat(v1.capacity) + parseFloat(v2.capacity) + parseFloat(v3.capacity);

                                    if (totalCapacity >= totalWeight) {
                                        const costV1 = (v1.fuel_amount * v1.fuelPrice / 100) * distanceKm;
                                        const costV2 = (v2.fuel_amount * v2.fuelPrice / 100) * distanceKm;
                                        const costV3 = (v3.fuel_amount * v3.fuelPrice / 100) * distanceKm;
                                        const cost = costV1 + costV2 + costV3;
                                        if (cost < bestThreeFuelCost) {
                                            let rem = totalWeight;
                                            const combo = [];

                                            const addVehicle = (v) => {
                                                const load = Math.min(v.capacity, rem);
                                                combo.push({ ...v, actual_load: load });
                                                rem -= load;
                                            };

                                            addVehicle(v1);
                                            addVehicle(v2);
                                            addVehicle(v3);

                                            bestThreeFuelCost = cost;
                                            bestThreeVehicleCombo = combo;
                                        }
                                    }
                                }
                            }
                        }

                        if (bestTwoVehicleCombo) {
                            // Distribute load between the two vehicles
                            const v1Load = Math.min(bestTwoVehicleCombo[0].capacity, totalWeight);
                            const v2Load = totalWeight - v1Load;

                            selectedVehicles.push(
                                { ...bestTwoVehicleCombo[0], actual_load: v1Load },
                                { ...bestTwoVehicleCombo[1], actual_load: v2Load }
                            );
                            remainingWeight = 0;
                        } else if (bestThreeVehicleCombo) {
                            // Distribute load between the two vehicles
                            const v1Load = Math.min(bestThreeVehicleCombo[0].capacity, totalWeight);
                            const v2Load = Math.min(bestThreeVehicleCombo[1].capacity, totalWeight);
                            const v3Load = totalWeight - v1Load - v2Load;

                            selectedVehicles.push(
                                { ...bestThreeVehicleCombo[0], actual_load: v1Load },
                                { ...bestThreeVehicleCombo[1], actual_load: v2Load },
                                { ...bestThreeVehicleCombo[2], actual_load: v3Load }
                            );
                            remainingWeight = 0;
                        } else {
                            // Fall back: use as many vehicles as needed, greedy strategy
                            let rem = totalWeight;

                            for (const vehicle of sortedVehicles) {
                                if (rem <= 0) break;

                                const load = Math.min(vehicle.capacity, rem);
                                selectedVehicles.push({ ...vehicle, actual_load: load });
                                rem -= load;
                            }

                            remainingWeight = rem; // If > 0, still not enough capacity
                        }
                    }
                }

                // Update UI with selected vehicles
                const carsContainer = document.getElementById('cars-container');
                carsContainer.innerHTML = '';
                
                if (selectedVehicles.length > 0 && remainingWeight <= 0) {
                    const vehicleNames = [];
                    const vehicleCapacities = [];
                    const vehicleFuelAmounts = [];
                    let totalFuelCost_ = 0;
                    
                    selectedVehicles.forEach(vehicle => {
                        const loadInfo = vehicle.actual_load ? ` (${vehicle.actual_load} кг)` : '';
                        const vehicleElement = document.createElement('div');
                        vehicleElement.className = 'vehicle-item';
                        vehicleElement.innerHTML = `
                            ${vehicle.name}${loadInfo} <span class="fuel-type">${vehicle.fuel_type}</span>
                            `;
                            // <span class="warehouse-source">(Склад ${vehicle.warehouse_id})</span>
                        carsContainer.appendChild(vehicleElement);
                        
                        vehicleNames.push(vehicle.name);
                        vehicleCapacities.push(vehicle.capacity);
                        vehicleFuelAmounts.push(vehicle.fuel_amount);

                        const vehicleCost = (vehicle.fuel_amount * vehicle.fuelPrice / 100) * distanceKm;
                        totalFuelCost_ += vehicleCost;
                    });
                    
                    document.getElementById('vehicle_name').value = vehicleNames.join(',');
                    document.getElementById('vehicle_capacity').value = vehicleCapacities.join(',');
                    document.getElementById('vehicle_fuel_amount').value = vehicleFuelAmounts.join(',');
                    
                    // Calculate total fuel cost based on actual distance and fuel consumption
                    // const distanceKm = totalDistance / 1000;
                    // const totalFuelCost = selectedVehicles.reduce((sum, vehicle) => {
                    //     return sum + (parseFloat(vehicle.fuel_amount) * vehicle.fuelPrice / 100 * distanceKm);
                    // }, 0);
                    
                    document.getElementById('fuel').innerHTML = totalFuelCost_.toFixed(2) + ' ₴';
                } else {
                    carsContainer.innerHTML = remainingWeight > 0 
                        ? 'Недостатньо вантажопідйомності' 
                        : 'Немає підходящого транспорту';
                    document.getElementById('fuel').innerHTML = '--';
                }
            } else {
                document.getElementById('cars-container').innerHTML = 'Немає доступного транспорту';
                document.getElementById('fuel').innerHTML = '--';
            }
        })
        .catch(error => {
            console.error('Error fetching vehicles:', error);
            document.getElementById('cars-container').innerHTML = 'Помилка завантаження';
            document.getElementById('fuel').innerHTML = '--';
        });
    }
}

function updateAvailableQuantities() {
    // Create a map to track used quantities per product
    const usedQuantities = new Map();
    
    // First pass: calculate total used quantities
    document.querySelectorAll('.field').forEach(field => {
        const select = field.querySelector('select.options');
        if (!select || !select.value) return;
        
        const productId = select.value;
        const amountInput = field.querySelector('input[type="text"]');
        const amount = parseInt(amountInput.value) || 0;
        
        if (usedQuantities.has(productId)) {
            usedQuantities.set(productId, usedQuantities.get(productId) + amount);
        } else {
            usedQuantities.set(productId, amount);
        }
    });
    
    // Second pass: update all select options
    document.querySelectorAll('select.options').forEach(select => {
        const currentProductId = select.value;
        
        Array.from(select.options).forEach(option => {
            if (!option.value) return;
            
            const totalAvailable = parseInt(option.dataset.amount) || 0;
            const used = usedQuantities.get(option.value) || 0;
            
            // If this is the currently selected product in another field
            if (option.value === currentProductId && select.value !== currentProductId) {
                used -= parseInt(select.parentElement.querySelector('input[type="text"]').value) || 0;
            }
            
            const remaining = totalAvailable - used;
            option.text = `${option.text.split(' (')[0]} (${remaining} шт. доступно)`;
            
            // Disable option if no quantity left
            option.disabled = remaining <= 0;
        });
    });
}


</script>

</body>
</html>
