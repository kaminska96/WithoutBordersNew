{% load static %}

<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="{% static 'header.css' %}">
    <link rel="stylesheet" href="{% static 'zamov.css' %}">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="shortcut icon" href="{% static 'favicon.ico' %}" type="image/x-icon">  
  <style>

    #map {
      height: 400px;
      width: 600px;
    }
  </style>
</head>
<body>
    <header>
        <img src="{% static 'logo.png' %}" alt="">
        <ul>
            <li style="padding:12px 32px;"><a href="/calendar" >Календар</a></li>
            <li style="padding:12px 32px;"><a href="/planned_orders" >Доставка</a></li>
            <li style="padding:12px 32px;background:#224F55; border-radius:10px"><a href="/creating_order" style="color:white;">Створити замовлення</a></li>
            <li style="padding:12px 32px;"><a href="/warehouses">Склади</a></li>
            <li style="padding:12px 32px;"><a href="/drivers">Водії</a></li>
        </ul>
        <form action="{% url 'logout' %}" method="post">
          {% csrf_token %}
  <button type="button" class="logout" id="logoutButton">
    <img src="{% static 'logout-icon.png' %}" alt="Logout" />
    <span>Вийти</span>
  </button>
        </form>
        
    </header>
    <div class="start">
      <div class="text">
        <h1 class="main_h1">Створити замовлення</h1>
      </div>
    </div>
    <section class="main_section">
      <div class="left">
        <form method="post" action="{% url 'create_order' %}">
          {% csrf_token %}
          <label for="order-name">Назва замовлення:</label>
          <input type="text" id="order_name" name="order_name"/>
          <div id="destinationsContainer">
            <label>Куди:</label>
            <div class="destination-field">
              <input type="text" style="margin-top: 20px;" class="end_input" id="end_input1" name="end_input[]" placeholder=""/>
              <button type="button" class="remove-destination" style="display:none;">×</button>
            </div>
          </div>
          <button type="button" onclick="addDestinationField()" class="add-destination-btn">
            <img src="{% static 'add-goods.png' %}"> Додати адресу
          </button>
          <label for="priority">Пріоритетність (від 1 до 100):</label>
          <input type="text" id="priority" name="priority" placeholder="" />
    
                <div id="addressProductsContainer">
                    <div class="address-products" data-address-id="1">
                    <label>Товари</label>
                        <div class="product-fields">
                            <div class="field">
                                <select name="options[1][]" class="options" style="width:359px" onchange="handleProductChange(this, 1)">
                                    <option value="">--- Виберіть товар ---</option>
                                    {% for product in products %}
                                    <option value="{{ product.id }}" data-amount="{{ product.amount }}" {% if product.amount <= 0 %}disabled{% endif %}>{{ product.name }} ({{ product.weight }} кг) - {{product.amount}} шт. доступно</option>
                                    {% endfor %}    
                                </select>
                                <input type="text" name="amount[1][]" placeholder="шт."/>
                                <button type="button" class="remove-product" onclick="removeProductField(this)" style="display:none;">×</button>
                            </div>
                        </div>
                        <button type="button" class="add-product-btn" onclick="addProductField(1)">
                            <img src="{% static 'add-goods.png' %}"> Додати товар
                        </button>
                    </div>
                </div>
          
            <!-- <button type="button" onclick="addFormField()" style="background: #FFFFFF;border: 1px solid #D0D0D0;box-shadow: 0px 4px 17px rgba(0, 0, 0, 0.1);border-radius: 15px;font-weight: 400;font-size: 16px;line-height: 24px;color: #7B7B7B;display: flex;align-items: center;justify-content: space-evenly;height: 57px;cursor: pointer;    width: 200px;"><img src="{% static 'add-goods.png' %}">
Додати товар</button> -->


            <label for="planned-date">Плановий початок доставки:</label>
            <div class="planned-time" style="display: flex; align-items: center; gap: 10px;">
    <input type="datetime-local" id="planned_date" name="planned_date" required 
           onchange="updatePlannedDateDisplay()">
    <span id="planned_date_display" style="font-size: 16px;"></span>
</div>

            <label for="estimated-end">Орієнтовне завершення:</label>
            <input type="text" id="estimated-end" readonly>
            <input type="datetime-local" class="estimated_date" id="estimated_date" name="estimated_date" style="display: none;" readonly>
            <div id="save">
            <button type="submit">Запланувати</button>
            </div>


        </div>
        <div class="right">
            <div id="map"></div>
            <div id="map_info">
                <div id="top">
                    <p>Дистанція</p>
                    <p>Час</p>
                    <p>Сума</p>
                </div>
                <div id="bottom">
                    <div id="msg"></div>
                    <div id="time"></div>
                    <!-- <div id="cars-container"></div> -->
                    <div id="fuel"></div>
                    <!-- <input type="hidden" name="vehicle_name" id="vehicle_name">
                    <input type="hidden" name="vehicle_capacity" id="vehicle_capacity">
                    <input type="hidden" name="vehicle_fuel_amount" id="vehicle_fuel_amount">
                    <input type="hidden" name="vehicle_fuel_type" id="vehicle_fuel_type"> -->
                </div>
            </div>
                <label for="start-input" style="margin-top: 40px;margin-bottom: 10px;">Звідки:</label>
                <input type="hidden" id="warehouse_id" name="warehouse_id">
                <div id="warehouses-display">
                <!-- Warehouses will be added here dynamically -->
            </div>
            <label style="margin-top: 35px;">Авто:</label>
            <div id="cars-container"></div>
            <input type="hidden" name="vehicle_name" id="vehicle_name">
            <input type="hidden" name="vehicle_capacity" id="vehicle_capacity">
            <input type="hidden" name="vehicle_fuel_amount" id="vehicle_fuel_amount">
            <input type="hidden" name="vehicle_fuel_type" id="vehicle_fuel_type">
            <input type="hidden" name="vehicle_driver" id="vehicle_driver">
        </form>
            <br />
        </div>
</section>

<div id="confirmationModal" class="modal" style="display: none;">
<div class="modal-content">
    <p>Чи ви впевнені, що хочете створити замовлення?</p>
    <div class="modal-buttons">
    <button id="confirmYes">Так</button>
    <button id="confirmNo">Ні</button>
    </div>
</div>
</div>

<div class="modal-overlay" id="logoutModal">
  <div class="modal-content">
    <h3 class="modal-title">Чи дійсно Ви бажаєте вийти з облікового запису?</h3>
    <div class="modal-buttons">
      <button class="modal-button modal-cancel" id="cancelLogout">Скасувати</button>
      <form action="{% url 'logout' %}" method="post" style="display: inline;">
        {% csrf_token %}
        <button type="submit" class="modal-button modal-confirm">Вийти</button>
      </form>
    </div>
  </div>
</div>
    
<script>


let warehouseMarkers = [];
let destinationMarkers = [];
let destinationAutocompletes = [];
var map;
var mk1; 
var directionsService;
var directionsRenderer;
var geocoder;

function initMap() {
    const center = { lat: 48.3794, lng: 31.1656 };
    const styles = [
        {
            featureType: 'all',
            elementType: 'labels',
            stylers: [{}]
        }
    ];
    const options = {
        zoom: 5.5555,
        scaleControl: true,
        center: center,
        styles: styles,
        disableDefaultUI: true
    };

    map = new google.maps.Map(document.getElementById('map'), options);
    const trafficLayer = new google.maps.TrafficLayer();
    trafficLayer.setMap(map);

    const warehouseMarkerStyle = {
        path: google.maps.SymbolPath.CIRCLE,
        scale: 8,
        fillColor: '#224F55',
        fillOpacity: 1,
        strokeWeight: 2,
        strokeColor: '#FFFFFF'
    };

    mk1 = new google.maps.Marker({ 
        map: map,
        icon: warehouseMarkerStyle
    });

    directionsService = new google.maps.DirectionsService();
    directionsRenderer = new google.maps.DirectionsRenderer({
        suppressMarkers: true, 
        polylineOptions: {
            strokeColor: '#224F55',
            strokeOpacity: 0.8,
            strokeWeight: 4
        }
    });
    directionsRenderer.setMap(map);

    geocoder = new google.maps.Geocoder();

    const startInput = document.getElementById('start_input');
    const startAutocomplete = new google.maps.places.Autocomplete(startInput);
    startAutocomplete.addListener('place_changed', function () {
        const place = startAutocomplete.getPlace();
        if (!place.geometry) return;
        const location = place.geometry.location;
        mk1.setPosition(location);
        map.panTo(location);
        calculateAndDisplayRoute();
    });

    const initialMarker = new google.maps.Marker({ 
        map: map,
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 6,
            fillColor: '#FF0000',
            fillOpacity: 1,
            strokeWeight: 1
        }
    });
    destinationMarkers.push(initialMarker);
    
    const endInput1 = document.getElementById('end_input1');
    const endAutocomplete = new google.maps.places.Autocomplete(endInput1);
    endAutocomplete.addListener('place_changed', function() {
        const place = this.getPlace();
        if (!place.geometry) return;
        updateDestination(0, place.geometry.location);

        const firstProductLabel = document.querySelector('.address-products label');
        if (firstProductLabel && place.formatted_address) {
            firstProductLabel.textContent = `Товари для ${place.formatted_address}`;
        }
    });
    destinationAutocompletes.push(endAutocomplete);

    endInput1.addEventListener('change', function() {
    //calculateAndDisplayRoute();
});

    endInput1.addEventListener('input', function() {
        const firstProductLabel = document.querySelector('.address-products label');
        if (firstProductLabel && this.value) {
            firstProductLabel.textContent = `Товари для ${this.value}`;
        }
    });

    endInput1.addEventListener('click', function() {
        const firstProductLabel = document.querySelector('.address-products label');
        if (firstProductLabel && this.value) {
            firstProductLabel.textContent = `Товари для ${this.value}`;
        }
    });

    endInput1.addEventListener('blur', function() {
        const firstProductLabel = document.querySelector('.address-products label');
        if (firstProductLabel && this.value) {
            firstProductLabel.textContent = `Товари для ${this.value}`;
        }
    });

    startInput.addEventListener('input', function () {
        const input = this.value;
        if (input) {
            geocoder.geocode({ address: input }, function (results, status) {
                if (status === 'OK' && results[0]) {
                    const location = results[0].geometry.location;
                    mk1.setPosition(location);
                    map.panTo(location);
                    calculateAndDisplayRoute();
                }
            });
        }
    });
}

function addDestinationField() {
    const container = document.getElementById('destinationsContainer');
    const count = destinationMarkers.length + 1;
    
    const newField = document.createElement('div');
    newField.className = 'destination-field';
    
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.className = 'end_input';
    newInput.id = `end_input${count}`;
    newInput.name = 'end_input[]';
    newInput.placeholder = '';
    
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'remove-destination';
    removeBtn.innerHTML = '×';
    removeBtn.onclick = function() {
        removeDestinationField(this, count-1);
    };
    
    newField.appendChild(newInput);
    newField.appendChild(removeBtn);
    container.appendChild(newField);
    
    const autocomplete = new google.maps.places.Autocomplete(newInput);
    autocomplete.addListener('place_changed', function() {
        const place = this.getPlace();
        if (!place.geometry) return;
        updateDestination(count-1, place.geometry.location);
        
        const productLabel = document.querySelector(`.address-products[data-address-id="${count}"] label`);
        if (productLabel && place.formatted_address) {
            productLabel.textContent = `Товари для ${place.formatted_address}`;
        }
    });
    destinationAutocompletes.push(autocomplete);
    
    const newMarker = new google.maps.Marker({
        map: map,
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 6,
            fillColor: '#FF0000',
            fillOpacity: 1,
            strokeWeight: 1
        }
    });
    destinationMarkers.push(newMarker);
    
    const removeButtons = document.querySelectorAll('.remove-destination');
    if (removeButtons.length > 1) {
        removeButtons.forEach(btn => btn.style.display = 'inline-block');
        removeButtons[0].style.display = 'none';
    }
        newInput.addEventListener('change', function() {
        //calculateAndDisplayRoute();
    });

    addProductFieldsForAddress(count);
    
    newInput.focus();
}

        
function addProductFieldsForAddress(addressId) {
    const container = document.getElementById('addressProductsContainer');
    
    const addressInput = document.getElementById(`end_input${addressId}`);
    const initialAddressValue = addressInput ? addressInput.value : `адреси ${addressId}`;
    
    const addressProductsDiv = document.createElement('div');
    addressProductsDiv.className = 'address-products';
    addressProductsDiv.setAttribute('data-address-id', addressId);
    
    const label = document.createElement('label');
    label.textContent = `Товари`;
    
    const productFieldsDiv = document.createElement('div');
    productFieldsDiv.className = 'product-fields';
    
    const firstField = document.createElement('div');
    firstField.className = 'field';
    firstField.innerHTML = `
        <select name="options[${addressId}][]" class="options" style="width:359px" onchange="handleProductChange(this, ${addressId})">
            <option value="">--- Виберіть товар ---</option>
            {% for product in products %}
            <option value="{{ product.id }}" data-amount="{{ product.amount }}">{{ product.name }} ({{ product.weight }} кг)</option>
            {% endfor %}
        </select>
        <input type="text" name="amount[${addressId}][]" placeholder="шт." />
        <button type="button" class="remove-product" onclick="removeProductField(this)" style="display:none;">×</button>
    `;
    
    productFieldsDiv.appendChild(firstField);
    
    const addButton = document.createElement('button');
    addButton.type = 'button';
    addButton.className = 'add-product-btn';
    addButton.innerHTML = `<img src="{% static 'add-goods.png' %}"> Додати товар`;
    addButton.onclick = function() { addProductField(addressId); };
    
    addressProductsDiv.appendChild(label);
    addressProductsDiv.appendChild(productFieldsDiv);
    addressProductsDiv.appendChild(addButton);
    
    container.appendChild(addressProductsDiv);
    
    if (addressInput) {
        // For Google Places Autocomplete
        const autocomplete = destinationAutocompletes[addressId - 1];
        if (autocomplete) {
            autocomplete.addListener('place_changed', function() {
                const place = autocomplete.getPlace();
                if (place && place.formatted_address) {
                    label.textContent = `Товари для ${place.formatted_address}`;
                }
            });
        }
        
        addressInput.addEventListener('input', function() {
            if (this.value) {
                label.textContent = `Товари для ${this.value}`;
            }
        });
        
        addressInput.addEventListener('click', function() {
            if (this.value) {
                label.textContent = `Товари для ${this.value}`;
            }
        });
        
        addressInput.addEventListener('blur', function() {
            if (this.value) {
                label.textContent = `Товари для ${this.value}`;
            }
        });
    }
        setupAmountFieldListeners();
    handleAmountChange()
}

function addProductField(addressId) {
    const addressProducts = document.querySelector(`.address-products[data-address-id="${addressId}"]`);
    if (!addressProducts) return;
    
    const productFields = addressProducts.querySelector('.product-fields');
    const fieldCount = productFields.querySelectorAll('.field').length + 1;
    
    const newField = document.createElement('div');
    newField.className = 'field';
    newField.innerHTML = `
        <select name="options[${addressId}][]" class="options" style="width:359px" onchange="handleProductChange(this, ${addressId})">
            <option value="">--- Виберіть товар ---</option>
            {% for product in products %}
            <option value="{{ product.id }}" data-amount="{{ product.amount }}">{{ product.name }} ({{ product.weight }} кг)</option>
            {% endfor %}
        </select>
        <input type="text" name="amount[${addressId}][]" placeholder="шт." />
        <button type="button" class="remove-product" onclick="removeProductField(this)">×</button>
    `;
    
    productFields.appendChild(newField);
    
    updateAvailableQuantities();
    setupAmountFieldListeners();
    handleAmountChange()
    
    const removeButtons = productFields.querySelectorAll('.remove-product');
    removeButtons.forEach(btn => btn.style.display = 'inline-block');
}

function removeProductField(button) {
    const field = button.closest('.field');
    const productFields = field.parentElement;
    
    field.remove();
    
    const remainingFields = productFields.querySelectorAll('.field');
    if (remainingFields.length <= 1) {
        productFields.querySelector('.remove-product').style.display = 'none';
    }

    updateAvailableQuantities();
    updateWarehousesDisplay();
    setupAmountFieldListeners();
    handleAmountChange()

  }

function removeDestinationField(button, index) {
    const field = button.parentNode;
    field.parentNode.removeChild(field);
    
    destinationMarkers[index].setMap(null);
    destinationMarkers.splice(index, 1);
    destinationAutocompletes.splice(index, 1);

    
    const addressId = index + 1; 
    const productFields = document.querySelector(`.address-products[data-address-id="${addressId}"]`);
    if (productFields) {
        productFields.remove();
    }

    updateWarehousesDisplay();
    
    setupAmountFieldListeners();
    
    handleAmountChange()
    
    if (fields.length <= 1) {
        document.querySelector('.remove-destination').style.display = 'none';
    }
}

function updateDestination(index, location) {
    if (!location) {
        const input = document.getElementById(`end_input${index+1}`);
        if (input.value) {
            geocoder.geocode({ address: input.value }, function(results, status) {
                if (status === 'OK' && results[0]) {
                    destinationMarkers[index].setPosition(results[0].geometry.location);
                }
            });
        }
        return;
    }
    
    destinationMarkers[index].setPosition(location);
    calculateAndDisplayRoute();
}

let fieldCounter = 0;

function addFormField() {
    const fieldCounter = document.getElementsByClassName('field').length + 1;

    const newField = document.createElement('div');
    newField.classList.add('field');
    newField.setAttribute('id', `field${fieldCounter}`);

    const newSelect = document.getElementById('productSelect1').cloneNode(true);
    newSelect.id = `productSelect${fieldCounter}`;
    newSelect.setAttribute('onchange', `handleProductChange(${fieldCounter})`);

    const newAmountInput = document.createElement('input');
    newAmountInput.type = 'text';
    newAmountInput.id = `amount${fieldCounter}`;
    newAmountInput.name = 'amount[]';
    newAmountInput.placeholder = 'шт.';

    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.id = 'remove_tovar';
    removeButton.className = 'remove-vehicle';

    const removeButtonImage = document.createElement('img');
    removeButtonImage.src = "../static/cross-circle.png";
    removeButtonImage.alt = "Видалити товар (Delete Product)";
    removeButton.appendChild(removeButtonImage);

    removeButton.addEventListener('click', function () {
        newField.remove();
        //updateWarehousesDisplay();
    });

    newField.appendChild(newSelect);
    newField.appendChild(newAmountInput);
    newField.appendChild(removeButton);

    document.getElementById('fieldsContainer').appendChild(newField);
}
</script>
<script
  async
  defer
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBM-PRyNaufp81rqWGvvM_6uCjhzKwj3bA&libraries=places&callback=initMap"
></script>
<script>
  
        function handleProductChange(selectElement, addressId) {
            const selectedProductId = selectElement.value;
            const selectedOption = selectElement.options[selectElement.selectedIndex];
            const productAmount = selectedOption.getAttribute('data-amount');

            const weightMatch = selectedOption.text.match(/\(([^)]+)\)/);
            const weightText = weightMatch ? weightMatch[1] : '';
            
            const amountInput = selectElement.parentElement.querySelector('input[type="text"]');
            const totalAvailable = parseInt(selectedOption.dataset.amount) || 0;
            amountInput.placeholder = `${totalAvailable} шт. доступно (${weightText})`;
            amountInput.dataset.available = totalAvailable;
                
                updateAvailableQuantities();

            fetch(`/api/warehouses/${selectedProductId}`)
                .then(response => response.json())
                .then(data => {
                    if (data) {
                        const amountInput = selectElement.parentElement.querySelector('input[type="text"]');
                        amountInput.placeholder = productAmount ? `${productAmount} шт.` : 'шт.';

                        const warehouseInfo = document.createElement('div');
                        warehouseInfo.className = 'warehouse-info';
                        warehouseInfo.innerHTML = `
                            <input type="hidden" class="product-warehouse" data-product-id="${selectedProductId}" 
                                   value="${data.id}" data-location="${data.location}" data-name="${data.name}">
                        `;
                        
                        const existingInfo = selectElement.parentNode.querySelector('.warehouse-info');
                        if (existingInfo) {
                            existingInfo.remove();
                        }
                        
                        selectElement.parentNode.appendChild(warehouseInfo);

                        updateWarehousesDisplay();
                    }
                })
                .catch(error => console.error(error));
                //calculateAndDisplayRoute()
        }

function updateWarehousesDisplay() {
    const warehouseInputs = document.querySelectorAll('.product-warehouse');
    const uniqueWarehouses = new Map();
    const warehousesDisplay = document.getElementById('warehouses-display');
    
    warehousesDisplay.innerHTML = '';
    
    warehouseInputs.forEach(input => {
        const warehouseId = input.value;
        if (!uniqueWarehouses.has(warehouseId)) {
            uniqueWarehouses.set(warehouseId, {
                id: warehouseId,
                name: input.dataset.name,
                location: input.dataset.location
            });
        }
    });

    document.getElementById('warehouse_id').value = Array.from(uniqueWarehouses.keys()).join(',');

    uniqueWarehouses.forEach((warehouse, id) => {
        const warehouseRow = document.createElement('div');
        warehouseRow.className = 'warehouse-row';
        warehouseRow.innerHTML = `
            <input type="text" value="${warehouse.name}" readonly class="warehouse-name">
            <input type="text" value="${warehouse.location}" readonly class="warehouse-location">
        `;
        warehousesDisplay.appendChild(warehouseRow);
    });

    warehouseMarkers.forEach(marker => marker.setMap(null));
    warehouseMarkers = [];

    if (uniqueWarehouses.size > 0) {
        const warehouseArray = Array.from(uniqueWarehouses.values());
        
        const firstWarehouse = warehouseArray[0];
        geocoder.geocode({ address: firstWarehouse.location }, function(results, status) {
            if (status === 'OK' && results[0]) {
                const location = results[0].geometry.location;
                mk1.setPosition(location);
                map.panTo(location);
                
                warehouseArray.forEach((warehouse, index) => {
                    geocoder.geocode({ address: warehouse.location }, (warehouseResults, warehouseStatus) => {
                        if (warehouseStatus === 'OK' && warehouseResults[0]) {
                            const warehouseLocation = warehouseResults[0].geometry.location;
                            const marker = new google.maps.Marker({
                                position: warehouseLocation,
                                map: map,
                                    icon: {
                                    path: google.maps.SymbolPath.CIRCLE,
                                    scale: 8,
                                    fillColor: '#224F55',
                                    fillOpacity: 1,
                                    strokeWeight: 2,
                                    strokeColor: '#FFFFFF'
                                }
                            });
                            warehouseMarkers.push(marker);
                        }
                    });
                });
                
                calculateAndDisplayRoute();
            }
        });
    } else {
        directionsRenderer.setDirections({routes: []});
        document.getElementById('msg').innerHTML = '--';
        document.getElementById('time').innerHTML = '--';
        document.getElementById('fuel').innerHTML = '--';
    }
}

function showLogoutModal() {
  const modal = document.getElementById('logoutModal');
  modal.classList.add('active');
}

function hideLogoutModal() {
  const modal = document.getElementById('logoutModal');
  modal.classList.remove('active');
}

document.addEventListener('DOMContentLoaded', function () {
    console.log('hi')
    setupAmountFieldListeners();


});

document.getElementById('logoutButton').addEventListener('click', showLogoutModal);
document.getElementById('cancelLogout').addEventListener('click', hideLogoutModal);

const logoutForm = document.querySelector('#logoutModal form');
if (logoutForm) {
logoutForm.addEventListener('submit', function(e) {
    
    hideLogoutModal();
});
}

function calculateTotalWeight() {
    let totalWeight = 0;
    
    const productFields = document.querySelectorAll('.address-products .field');
    
    productFields.forEach(field => {
        const select = field.querySelector('select.options');
        console.log(1);
        if (!select) return;
        
        const selectedOption = select.options[select.selectedIndex];
        console.log(2);
        if (!selectedOption || selectedOption.value === "") return;
        
        const weightText = selectedOption.textContent;
        const weightMatch = weightText.match(/\((\d+\.?\d*)\s*кг\)/);
        console.log(3);
        if (!weightMatch) return;
        
        const weightPerItem = parseFloat(weightMatch[1]);
        
        const quantityInput = field.querySelector('input[type="text"]');
        console.log(4);
        if (!quantityInput) return;
        
        const quantity = parseInt(quantityInput.value) || 0;
        console.log(weightPerItem);
        console.log(quantity);
        
        totalWeight += weightPerItem * quantity;
    });
    
    console.log('Total weight calculated:', totalWeight);
    return totalWeight;
}

function setupAmountFieldListeners() {
    const amountInputs = document.querySelectorAll('.address-products input[type="text"][name^="amount"]');
    
    amountInputs.forEach(input => {
        //input.removeEventListener('input', handleAmountChange);
        
        input.addEventListener('input', handleAmountChange);
        //calculateAndDisplayRoute();
    });
}

function handleAmountChange() {
    updateAvailableQuantities();
    const totalWeight = calculateTotalWeight();
    calculateAndDisplayRoute();
    document.getElementById('total-weight-display').textContent = `${totalWeight} кг`;
}


// document.getElementById('start_input').addEventListener('input', function () {
//     if (this.value.trim() !== '') {
//         calculateAndDisplayRoute();
//     }
// });

// document.getElementById('end_input').addEventListener('input', function () {
//     if (this.value.trim() !== '') {
//         calculateAndDisplayRoute();
//     }
// });

const dateTimeInput = document.getElementById('planned_date');

// document.getElementById('planned_date').addEventListener('change', function() {
//     console.log('Selected date/time:');
//     if (directionsRenderer.getDirections()) {
//         const route = directionsRenderer.getDirections().routes[0];
//         let totalDuration = 0;
//         route.legs.forEach(leg => {
//             totalDuration += leg.duration.value;
//         });
//         updateEstimatedEndTime(totalDuration);
//     }
// });

window.onload = function() {
    let date = document.getElementById('planned_date');
    date.addEventListener('change', function() {
        console.log('date change');
        calculateAndDisplayRoute()
    });
}

function findOptimalWarehouseOrder(warehouses, startLocation) {
    return warehouses.sort((a, b) => {
        const distA = google.maps.geometry.spherical.computeDistanceBetween(
            startLocation, 
            new google.maps.LatLng(a.lat, a.lng)
        );
        const distB = google.maps.geometry.spherical.computeDistanceBetween(
            startLocation, 
            new google.maps.LatLng(b.lat, b.lng)
        );
        return distA - distB;
    });
}

function calculateAndDisplayRoute() {
    const startLocation = mk1.getPosition();
    if (!startLocation) return;

    const warehouseRows = document.querySelectorAll('#warehouses-display .warehouse-row');
    const warehouses = [];
    
    warehouseRows.forEach(row => {
        const locationInput = row.querySelector('.warehouse-location');
        if (locationInput && locationInput.value) {
            warehouses.push({
                location: locationInput.value,
                name: row.querySelector('.warehouse-name').value
            });
        }
    });

    if (warehouses.length === 0) {
        calculateRouteWithDestinationsOnly(startLocation);
        return;
    }

    Promise.all(warehouses.map(warehouse => {
        return new Promise((resolve) => {
            geocoder.geocode({ address: warehouse.location }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    resolve({
                        ...warehouse,
                        position: results[0].geometry.location,
                        lat: results[0].geometry.location.lat(),
                        lng: results[0].geometry.location.lng()
                    });
                } else {
                    resolve(null);
                }
            });
        });
    })).then(geocodedWarehouses => {
        const validWarehouses = geocodedWarehouses.filter(w => w !== null);
        displayWarehouseMarkers(validWarehouses);
        calculateFullRoute(validWarehouses, startLocation);
    });
}

function calculateRouteWithDestinationsOnly(startLocation) {
    const destinations = [];
    for (let i = 0; i < destinationMarkers.length; i++) {
        const position = destinationMarkers[i].getPosition();
        if (position) {
            destinations.push({
                position: position,
                id: i
            });
        }
    }

    if (destinations.length === 0) {
        directionsRenderer.setDirections({routes: []});
        return;
    }

    destinations.sort((a, b) => {
        const distA = google.maps.geometry.spherical.computeDistanceBetween(startLocation, a.position);
        const distB = google.maps.geometry.spherical.computeDistanceBetween(startLocation, b.position);
        return distA - distB;
    });

    const waypoints = [];
    if (destinations.length > 1) {
        for (let i = 0; i < destinations.length - 1; i++) {
            waypoints.push({
                location: destinations[i].position,
                stopover: true
            });
        }
    }

    const finalDestination = destinations[destinations.length - 1].position;

    const route = {
        origin: startLocation,
        destination: finalDestination,
        waypoints: waypoints,
        travelMode: 'DRIVING',
        optimizeWaypoints: true,
        provideRouteAlternatives: false
    };

    directionsService.route(route, function(response, status) {
        if (status !== 'OK') {
            console.error('Directions request failed:', status);
            document.getElementById('msg').innerHTML = 'Помилка маршруту';
            document.getElementById('time').innerHTML = '--';
            return;
        }

        directionsRenderer.setDirections(response);
        updateRouteInfo(response);
    });
}

function calculateFullRoute(warehouses, startLocation) {
    const destinations = [];
    for (let i = 0; i < destinationMarkers.length; i++) {
        const position = destinationMarkers[i].getPosition();
        if (position) {
            destinations.push({
                position: position,
                id: i
            });
        }
    }

    const optimalWarehouses = findOptimalWarehouseOrder(warehouses, startLocation);
    
    const waypoints = [];
    
    if (optimalWarehouses.length > 1) {
        for (let i = 1; i < optimalWarehouses.length; i++) {
            waypoints.push({
                location: optimalWarehouses[i].position,
                stopover: true
            });
        }
    }

    const lastWarehouse = optimalWarehouses[optimalWarehouses.length - 1].position;
    destinations.sort((a, b) => {
        const distA = google.maps.geometry.spherical.computeDistanceBetween(lastWarehouse, a.position);
        const distB = google.maps.geometry.spherical.computeDistanceBetween(lastWarehouse, b.position);
        return distA - distB;
    });
    
    if (destinations.length > 1) {
        for (let i = 0; i < destinations.length - 1; i++) {
            waypoints.push({
                location: destinations[i].position,
                stopover: true
            });
        }
    }

    displayWarehouseMarkers(optimalWarehouses);

    const finalDestination = destinations.length > 0 ? destinations[destinations.length - 1].position : startLocation;

    const route = {
        origin: startLocation,
        destination: finalDestination,
        waypoints: waypoints,
        travelMode: 'DRIVING',
        optimizeWaypoints: true,
        provideRouteAlternatives: false
    };

    directionsService.route(route, function(response, status) {
        if (status !== 'OK') {
            console.error('Directions request failed:', status);
            document.getElementById('msg').innerHTML = 'Помилка маршруту';
            document.getElementById('time').innerHTML = '--';
            return;
        }

        directionsRenderer.setDirections(response);
        updateRouteInfo(response);
    });
}

function displayWarehouseMarkers(warehouses) {
    // warehouseMarkers.forEach(marker => marker.setMap(null));
    // warehouseMarkers = [];

    warehouses.forEach((warehouse) => {
        const marker = new google.maps.Marker({
            position: warehouse.location,
            map: map,
            icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: '#224F55',
            fillOpacity: 1,
            strokeWeight: 2,
            strokeColor: '#FFFFFF'
        }
        });
        warehouseMarkers.push(marker);
    });
}

function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    let result = '';
    if (hours > 0) result += hours + ' год. ';
    result += minutes + ' хв.';
    return result;
}

function updatePlannedDateDisplay() {
    const startDateInput = document.getElementById('planned_date');
    const displayElement = document.getElementById('planned_date_display');
    
    if (!startDateInput.value) {
        displayElement.textContent = '';
        return;
    }
    
    const startDate = new Date(startDateInput.value);
    const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    };
    
    displayElement.textContent = startDate.toLocaleDateString('uk-UA', options);
}

function updateEstimatedEndTime(durationSeconds) {
    const startDateInput = document.getElementById('planned_date');
    const estimatedEndInput = document.getElementById('estimated-end');
    const estimatedDateInput = document.getElementById('estimated_date');
    
    if (!startDateInput.value) {
        estimatedEndInput.value = 'Вкажіть дату початку';
        estimatedDateInput.value = '';
        return;
    }
    
    const startDate = new Date(startDateInput.value);
    const endDate = new Date(startDate.getTime() + durationSeconds * 1000);
    
    const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    };
    estimatedEndInput.value = endDate.toLocaleDateString('uk-UA', options);
    
    const formatForDateTimeLocal = (date) => {
        const offset = 3 * 60 * 60 * 1000;
        const localDate = new Date(date.getTime() + offset);
        
        const pad = num => num.toString().padStart(2, '0');
        return `${localDate.getUTCFullYear()}-${pad(localDate.getUTCMonth() + 1)}-${pad(localDate.getUTCDate())}T${pad(localDate.getUTCHours())}:${pad(localDate.getUTCMinutes())}`;
    };
    
    estimatedDateInput.value = formatForDateTimeLocal(endDate);
}

function updateRouteInfo(response) {
    const route = response.routes[0];
    let totalDistance = 0;
    let totalDuration = 0;
    
    route.legs.forEach(leg => {
        totalDistance += leg.distance.value;
        totalDuration += leg.duration.value;
    });

    routeDuration = totalDuration;

    // Update UI
    mapInfo = document.getElementById('map_info');
    mapInfo.style.display = 'flex';
    document.getElementById('msg').innerHTML = (totalDistance / 1000).toFixed(1) + ' км';
    document.getElementById('time').innerHTML = formatDuration(totalDuration);
    updateEstimatedEndTime(totalDuration);

    // Calculate vehicle and fuel costs
    const warehouseIds = document.getElementById("warehouse_id").value.split(',');
    const totalWeight = calculateTotalWeight();
    
    if (warehouseIds.length > 0 && totalWeight) {
        Promise.all([
            fetch('/api/fuel-prices/')
                .then(response => response.json())
                .catch(error => {
                    console.error('Error fetching fuel prices:', error);
                    return { prices: { 'A-95': 55 } }; 
                }),
            ...warehouseIds.map(id => 
                fetch(`/api/vehicle/${id.trim()}`)
                    .then(response => response.json())
                    .catch(error => {
                        console.error(`Error fetching vehicles for warehouse ${id}:`, error);
                        return [];
                    })
            )
        ])
        .then(([fuelPrices, ...warehouseVehicles]) => {
            const allVehicles = warehouseVehicles.flat();
            const distanceKm = totalDistance / 1000;
            
            const fuelPriceMap = {
                'Бензин А-95 преміум': fuelPrices.prices?.['A-95 преміум'] || 58.70,
                'Бензин А-95': fuelPrices.prices?.['A-95'] || 54.47,
                'Бензин А-92': fuelPrices.prices?.['A-92'] || 51.95,
                'Дизельне паливо': fuelPrices.prices?.['Дизельне паливо'] || 52.61,
                'Газ автомобільний': fuelPrices.prices?.['Газ автомобільний'] || 34.90
            };
            
            if (allVehicles.length > 0) {
                const vehicles = allVehicles.map(vehicle => {
                    const fuelPrice = fuelPriceMap[vehicle.fuel_type] || 54.47;
                    return {
                        ...vehicle,
                        fuelPrice,
                        efficiency: (vehicle.fuel_amount * fuelPrice / 100),
                        capacity: parseFloat(vehicle.capacity),
                        used: false
                    };
                });

                vehicles.sort((a, b) => {
                    if (a.efficiency === b.efficiency) {
                        return b.capacity - a.capacity;
                    }
                    return a.efficiency - b.efficiency;
                });

                const allCombinations = findAllVehicleCombinations(vehicles, totalWeight, distanceKm);
                
                const optimalCombination = findOptimalCombination(allCombinations);

                updateVehicleSelectionUI(optimalCombination, distanceKm);
            } else {
                document.getElementById('cars-container').innerHTML = 'Немає доступного транспорту';
                document.getElementById('fuel').innerHTML = '--';
            }
        })
        .catch(error => {
            console.error('Error fetching vehicles:', error);
            document.getElementById('cars-container').innerHTML = 'Помилка завантаження';
            document.getElementById('fuel').innerHTML = '--';
        });
    }
}

function findAllVehicleCombinations(vehicles, totalWeight, distanceKm) {
    const combinations = [];
    
    function findCombinations(currentCombination, startIndex, remainingWeight) {
        if (remainingWeight <= 0) {
            const totalCost = currentCombination.reduce((sum, vehicle) => {
                return sum + (vehicle.fuel_amount * vehicle.fuelPrice / 100 * distanceKm);
            }, 0);
            
            combinations.push({
                vehicles: [...currentCombination],
                totalCost,
                remainingCapacity: currentCombination.reduce((sum, v) => sum + v.capacity, 0) - totalWeight
            });
            return;
        }
        
        for (let i = startIndex; i < vehicles.length; i++) {
            const vehicle = vehicles[i];
            
            if (vehicle.used || vehicle.capacity <= 0) continue;
            
            const load = Math.min(vehicle.capacity, remainingWeight);
            
            const loadedVehicle = {
                ...vehicle,
                actual_load: load,
                used: true
            };
            
            currentCombination.push(loadedVehicle);
            findCombinations(
                currentCombination, 
                i + 1, 
                remainingWeight - load
            );
            
            currentCombination.pop();
            vehicle.used = false;
        }
    }
    
    findCombinations([], 0, totalWeight);
    
    return combinations;
}

function findOptimalCombination(combinations) {
    if (combinations.length === 0) {
        return null;
    }
    
    let optimal = combinations[0];
    for (let i = 1; i < combinations.length; i++) {
        if (combinations[i].totalCost < optimal.totalCost) {
            optimal = combinations[i];
        }
    }
    
    return optimal;
}

let vehicleUIAlreadyRendered = false;

function updateVehicleSelectionUI(combination, distanceKm) {
    if (vehicleUIAlreadyRendered) {
        console.log("Skipping duplicate UI render");
        return;
    }
    vehicleUIAlreadyRendered = true;
    
    const carsContainer = document.getElementById('cars-container');
    carsContainer.innerHTML = '';

    if (!combination || combination.vehicles.length === 0) {
        carsContainer.innerHTML = 'Недостатньо вантажопідйомності';
        document.getElementById('fuel').innerHTML = '--';
        return;
    }

    fetch('/api/driver/')
        .then(response => response.json())
        .then(drivers => {
            const vehicleNames = [];
            const vehicleCapacities = [];
            const vehicleFuelAmounts = [];
            const vehicleFuelTypes = [];
            let totalFuelCost = 0;

            combination.vehicles.forEach((vehicle, index) => {
                const loadInfo = vehicle.actual_load ? ` (${vehicle.actual_load} кг)` : '';

                const vehicleElement = document.createElement('div');
                vehicleElement.className = 'vehicle-item';

                const driverContainer = document.createElement('div');
                driverContainer.className = 'driver-container';
                
                const driverSelect = document.createElement('select');
                driverSelect.name = `vehicle_drivers[]`;
                driverSelect.className = 'driver-select';
                driverSelect.required = true;
                driverSelect.dataset.index = index; 

                driverSelect.addEventListener('change', function() {
                    updateDriverHiddenField();
                });

                const defaultOption = document.createElement('option');
                defaultOption.value = '';
                defaultOption.textContent = '--- Виберіть водія ---';
                defaultOption.selected = true;
                defaultOption.disabled = true;
                driverSelect.appendChild(defaultOption);

                drivers.forEach(driver => {
                    const option = document.createElement('option');
                    option.value = driver.id;
                    option.textContent = `${driver.name} ${driver.surname} (${driver.phone})`;
                    driverSelect.appendChild(option);
                });

                vehicleElement.innerHTML = `
                    <div class="vehicle-info">
                        ${vehicle.name}${loadInfo} <span class="fuel-type">${vehicle.fuel_type}</span>
                    </div>
                `;
                
                const driverLabel = document.createElement('label');
                driverLabel.textContent = 'Водій:';
                driverContainer.appendChild(driverLabel);
                driverContainer.appendChild(driverSelect);
                vehicleElement.appendChild(driverContainer);
                
                carsContainer.appendChild(vehicleElement);

                vehicleNames.push(vehicle.name);
                vehicleCapacities.push(vehicle.capacity);
                vehicleFuelAmounts.push(vehicle.fuel_amount);
                vehicleFuelTypes.push(vehicle.fuel_type);

                totalFuelCost += (vehicle.fuel_amount * vehicle.fuelPrice / 100) * distanceKm;
            });

            document.getElementById('vehicle_name').value = vehicleNames.join(',');
            document.getElementById('vehicle_capacity').value = vehicleCapacities.join(',');
            document.getElementById('vehicle_fuel_amount').value = vehicleFuelAmounts.join(',');
            document.getElementById('vehicle_fuel_type').value = vehicleFuelTypes.join(',');
            document.getElementById('fuel').innerHTML = totalFuelCost.toFixed(2) + ' ₴';

            updateDriverHiddenField();
        })
        .catch(error => {
            console.error("Error fetching drivers:", error);
            carsContainer.innerHTML = 'Помилка при завантаженні водіїв.';
        });
    
    setTimeout(() => vehicleUIAlreadyRendered = false, 500);
}

function updateDriverHiddenField() {
    const driverSelects = document.querySelectorAll('.driver-select');
    const selectedDrivers = [];
    
    driverSelects.forEach(select => {
        if (select.value) {
            selectedDrivers.push(select.value);
        }
    });
    
    document.getElementById('vehicle_driver').value = selectedDrivers.join(',');
}

document.querySelector('form').addEventListener('submit', function(e) {
    const driverSelects = document.querySelectorAll('.driver-select');
    let allDriversSelected = true;
    
    driverSelects.forEach(select => {
        if (!select.value) {
            allDriversSelected = false;
            select.style.border = '1px solid red';
        } else {
            select.style.border = '';
        }
    });
    
    if (!allDriversSelected) {
        e.preventDefault();
        alert('Будь ласка, виберіть водіїв для всіх транспортних засобів');
        return false;
    }
    
    return true;
});



function updateAvailableQuantities() {
    const usedQuantities = new Map();
    
    document.querySelectorAll('.field').forEach(field => {
        const select = field.querySelector('select.options');
        if (!select || !select.value) return;
        
        const productId = select.value;
        const amountInput = field.querySelector('input[type="text"]');
        const amount = parseInt(amountInput.value) || 0;
        
        if (usedQuantities.has(productId)) {
            usedQuantities.set(productId, usedQuantities.get(productId) + amount);
        } else {
            usedQuantities.set(productId, amount);
        }
    });
    
    document.querySelectorAll('select.options').forEach(select => {
        const currentProductId = select.value;
        
        Array.from(select.options).forEach(option => {
            if (!option.value) return;
            
            const originalText = option.text.split(' (')[0]; 
            const weightMatch = option.text.match(/\(([^)]+)\)/); 
            const weightText = weightMatch ? weightMatch[1] : '';
            
            const totalAvailable = parseInt(option.dataset.amount) || 0;
            const used = usedQuantities.get(option.value) || 0;
            
            if (option.value === currentProductId && select.value !== currentProductId) {
                used -= parseInt(select.parentElement.querySelector('input[type="text"]').value) || 0;
            }
            
            const remaining = totalAvailable - used;
            
            option.text = `${originalText} (${weightText}) - ${remaining} шт. доступно`;
            
            option.disabled = remaining <= 0 && select.value !== option.value;
        });
    });
}


</script>

</body>
</html>
