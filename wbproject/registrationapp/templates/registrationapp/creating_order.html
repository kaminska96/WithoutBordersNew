{% load static %}

<!DOCTYPE html>
<html>
<head>
    <link rel="stylesheet" href="{% static 'header.css' %}">
    <link rel="stylesheet" href="{% static 'zamov.css' %}">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="shortcut icon" href="{% static 'favicon.ico' %}" type="image/x-icon">  
  <style>

    #map {
      height: 400px;
      width: 600px;
    }
  </style>
</head>
<body>
    <header>
        <img src="{% static 'logo.png' %}" alt="">
        <ul>
            <li style="padding:12px 32px;"><a href="/planned_orders" >Доставка</a></li>
            <li style="padding:12px 32px;background:#224F55; border-radius:10px"><a href="/creating_order" style="color:white;">Створити замовлення</a></li>
            <li style="padding:12px 32px;"><a href="/warehouses">Склади</a></li>
        </ul>
        <form action="{% url 'logout' %}" method="post">
          {% csrf_token %}
          <button type="submit" class="logout">
            <img src="{% static 'logout-icon.png' %}" alt="Logout">
            <span>Вийти</span>
          </button>
        </form>
        
    </header>
    <div class="start">
      <div class="text">
        <h1 class="main_h1">Створити замовлення</h1>
      </div>
    </div>
    <section class="main_section">
      <div class="left">
        <form method="post" action="{% url 'create_order' %}">
          {% csrf_token %}
          <label for="order-name">Назва замовлення:</label>
          <input type="text" id="order_name" name="order_name"/>
          <!-- <label for="end-input">Куди:</label> -->
          <div id="destinationsContainer">
            <label>Куди:</label>
            <div class="destination-field">
              <input type="text" class="end_input" id="end_input1" name="end_input[]" placeholder=""/>
              <button type="button" class="remove-destination" style="display:none;">×</button>
            </div>
          </div>
          <button type="button" onclick="addDestinationField()" class="add-destination-btn">
            <img src="{% static 'add-goods.png' %}"> Додати адресу
          </button>
          <label for="priority">Пріоритетність (від 1 до 100):</label>
          <input type="text" id="priority" name="priority" placeholder="" />
    
          <label>Товари</label>
          <form id="myForm">
            <div id="fieldsContainer" style="
            display: flex;
            flex-direction: column;
            gap: 10px;">
              <div class="field">
                <select name="options[]" class="options" style="width:359px" id="productSelect1" onchange="handleProductChange(1)">
                  <option value="">--- Виберіть товар ---</option>
                  {% for product in products %}
                  <option value="{{ product.id }}" data-amount="{{ product.amount }}">{{ product.name }} ({{ product.weight }} кг)</option>
                  {% endfor %}
                </select>
                <input type="text" id="amount1" name="amount[]" placeholder="шт." />
              </div>
            </div>
          
            <button type="button" onclick="addFormField()" style="background: #FFFFFF;border: 1px solid #D0D0D0;box-shadow: 0px 4px 17px rgba(0, 0, 0, 0.1);border-radius: 15px;font-weight: 400;font-size: 16px;line-height: 24px;color: #7B7B7B;display: flex;align-items: center;justify-content: space-evenly;height: 57px;cursor: pointer;    width: 200px;"><img src="{% static 'add-goods.png' %}">
Додати товар</button>
            <label for="start-input">Звідки:</label>
            <input type="hidden" id="warehouse_id" name="warehouse_id">
            <div id="warehouses-display">
                <!-- Warehouses will be added here dynamically -->
            </div>
            <label for="planned-date">Плановий початок доставки:</label>
            <input type="datetime-local" class="planned_date" id="planned_date" name="planned_date" required>

            <label for="estimated-end">Орієнтовне завершення:</label>
            <input type="text" id="estimated-end" readonly>
            <input type="datetime-local" class="estimated_date" id="estimated_date" name="estimated_date" style="display: none;" readonly>
            <div id="save">
              <button type="submit">Запланувати</button>
          </div>

        </div>
        <div class="right">
            <div id="map"></div>
            <div id="map_info">
                <div id="top">
                    <p>Дистанція</p>
                    <p style="padding-right: 54px;">Час</p>
                    <p style="padding-right: 26px;">Машина</p>
                    <p>Сума</p>
                </div>
                <div id="bottom">
                    <div id="msg"></div>
                    <div id="time"></div>
                    <div id="car"></div>
                    <div id="fuel"></div>
                    <input type="hidden" name="vehicle_name" id="vehicle_name">
                    <input type="hidden" name="vehicle_capacity" id="vehicle_capacity">
                    <input type="hidden" name="vehicle_fuel_amount" id="vehicle_fuel_amount">
                </div>
            </div>
          </form>
        </form>
            <br />
        </div>
    
<script>

let destinationMarkers = [];
let destinationAutocompletes = [];
var map;
var mk1; 
var directionsService;
var directionsRenderer;
var geocoder;

function initMap() {
    const center = { lat: 48.3794, lng: 31.1656 };
    const styles = [
        {
            featureType: 'all',
            elementType: 'labels',
            stylers: [{}]
        }
    ];
    const options = {
        zoom: 5.5555,
        scaleControl: true,
        center: center,
        styles: styles,
        disableDefaultUI: true
    };

    map = new google.maps.Map(document.getElementById('map'), options);
    const trafficLayer = new google.maps.TrafficLayer();
    trafficLayer.setMap(map);

    // Warehouse marker (start point)
    mk1 = new google.maps.Marker({ 
        map: map,
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 8,
            fillColor: '#224F55',
            fillOpacity: 1,
            strokeWeight: 2,
            strokeColor: '#FFFFFF'
        }
    });

    directionsService = new google.maps.DirectionsService();
    directionsRenderer = new google.maps.DirectionsRenderer({
        suppressMarkers: true, // We'll use our own markers
        polylineOptions: {
            strokeColor: '#224F55',
            strokeOpacity: 0.8,
            strokeWeight: 4
        }
    });
    directionsRenderer.setMap(map);

    geocoder = new google.maps.Geocoder();

    // Warehouse location input
    const startInput = document.getElementById('start_input');
    const startAutocomplete = new google.maps.places.Autocomplete(startInput);
    startAutocomplete.addListener('place_changed', function () {
        const place = startAutocomplete.getPlace();
        if (!place.geometry) return;
        const location = place.geometry.location;
        mk1.setPosition(location);
        map.panTo(location);
        calculateAndDisplayRoute();
    });

    // Initialize with first destination marker
    const initialMarker = new google.maps.Marker({ 
        map: map,
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 6,
            fillColor: '#FF0000',
            fillOpacity: 1,
            strokeWeight: 1
        }
    });
    destinationMarkers.push(initialMarker);
    
    // Initialize first destination autocomplete
    const endInput1 = document.getElementById('end_input1');
    const endAutocomplete = new google.maps.places.Autocomplete(endInput1);
    endAutocomplete.addListener('place_changed', function() {
        const place = this.getPlace();
        if (!place.geometry) return;
        updateDestination(0, place.geometry.location);
    });
    destinationAutocompletes.push(endAutocomplete);

    // Listen for input changes to manually trigger geocoding
    startInput.addEventListener('input', function () {
        const input = this.value;
        if (input) {
            geocoder.geocode({ address: input }, function (results, status) {
                if (status === 'OK' && results[0]) {
                    const location = results[0].geometry.location;
                    mk1.setPosition(location);
                    map.panTo(location);
                    calculateAndDisplayRoute();
                }
            });
        }
    });
}


        function addDestinationField() {
    const container = document.getElementById('destinationsContainer');
    const count = destinationMarkers.length + 1;
    
    // Create new field
    const newField = document.createElement('div');
    newField.className = 'destination-field';
    
    // Create new input
    const newInput = document.createElement('input');
    newInput.type = 'text';
    newInput.className = 'end_input';
    newInput.id = `end_input${count}`;
    newInput.name = 'end_input[]';
    newInput.placeholder = '';
    
    // Create remove button
    const removeBtn = document.createElement('button');
    removeBtn.type = 'button';
    removeBtn.className = 'remove-destination';
    removeBtn.innerHTML = '×';
    removeBtn.onclick = function() {
        removeDestinationField(this, count-1);

    calculateAndDisplayRoute()
    };
    
    // Add label
    const label = document.createElement('label');
    label.htmlFor = `end_input${count}`;
    label.textContent = `Адреса доставки ${count}:`;
    
    // Append elements
    newField.appendChild(label);
    newField.appendChild(newInput);
    newField.appendChild(removeBtn);
    container.appendChild(newField);
    
    // Initialize autocomplete
    const autocomplete = new google.maps.places.Autocomplete(newInput);
    autocomplete.addListener('place_changed', function() {
        updateDestination(count-1);
    });
    destinationAutocompletes.push(autocomplete);
    
    // Add new marker
    const newMarker = new google.maps.Marker({
        map: map,
        icon: {
            path: google.maps.SymbolPath.CIRCLE,
            scale: 6,
            fillColor: '#FF0000',
            fillOpacity: 1,
            strokeWeight: 1
        }
    });
    destinationMarkers.push(newMarker);
    
    // Show remove buttons on all but first
    const removeButtons = document.querySelectorAll('.remove-destination');
    if (removeButtons.length > 1) {
        removeButtons.forEach(btn => btn.style.display = 'inline-block');
    }
}

function removeDestinationField(button, index) {
    const field = button.parentNode;
    field.parentNode.removeChild(field);
    
    // Remove marker and autocomplete
    destinationMarkers[index].setMap(null);
    destinationMarkers.splice(index, 1);
    destinationAutocompletes.splice(index, 1);
    
    // Renumber remaining fields
    const fields = document.querySelectorAll('.destination-field');
    fields.forEach((field, i) => {
        const label = field.querySelector('label');
        label.textContent = `Адреса доставки ${i+1}:`;
        const input = field.querySelector('input');
        input.id = `end_input${i+1}`;
    });
    
    // Hide remove button if only one left
    if (fields.length <= 1) {
        document.querySelector('.remove-destination').style.display = 'none';
    }
    
    // Recalculate route
    calculateAndDisplayRoute();
}

function updateDestination(index, location) {
    if (!location) {
        const input = document.getElementById(`end_input${index+1}`);
        if (input.value) {
            geocoder.geocode({ address: input.value }, function(results, status) {
                if (status === 'OK' && results[0]) {
                    destinationMarkers[index].setPosition(results[0].geometry.location);
                    calculateAndDisplayRoute();
                }
            });
        }
        return;
    }
    
    destinationMarkers[index].setPosition(location);
    calculateAndDisplayRoute();
}

let fieldCounter = 0;

function addFormField() {
    const fieldCounter = document.getElementsByClassName('field').length + 1;

    const newField = document.createElement('div');
    newField.classList.add('field');
    newField.setAttribute('id', `field${fieldCounter}`);

    const newSelect = document.getElementById('productSelect1').cloneNode(true);
    newSelect.id = `productSelect${fieldCounter}`;
    newSelect.setAttribute('onchange', `handleProductChange(${fieldCounter})`);

    const newAmountInput = document.createElement('input');
    newAmountInput.type = 'text';
    newAmountInput.id = `amount${fieldCounter}`;
    newAmountInput.name = 'amount[]';
    newAmountInput.placeholder = 'шт.';

    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.id = 'remove_tovar';
    removeButton.className = 'remove-vehicle';

    const removeButtonImage = document.createElement('img');
    removeButtonImage.src = "../static/cross-circle.png";
    removeButtonImage.alt = "Видалити товар (Delete Product)";
    removeButton.appendChild(removeButtonImage);

    removeButton.addEventListener('click', function () {
        newField.remove();
        updateWarehousesDisplay();
    });

    newField.appendChild(newSelect);
    newField.appendChild(newAmountInput);
    newField.appendChild(removeButton);

    document.getElementById('fieldsContainer').appendChild(newField);
}
</script>
<script
  async
  defer
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBM-PRyNaufp81rqWGvvM_6uCjhzKwj3bA&libraries=places&callback=initMap"
></script>
<script>
  
function handleProductChange(fieldCounter) {
    const selectElement = document.getElementById(`productSelect${fieldCounter}`);
    const selectedProductId = selectElement.value;
    const selectedOption = selectElement.options[selectElement.selectedIndex];
    const productAmount = selectedOption.getAttribute('data-amount');

    fetch(`/api/warehouses/${selectedProductId}`)
        .then(response => response.json())
        .then(data => {
            if (data) {
                const amountInput = document.getElementById(`amount${fieldCounter}`);
                amountInput.placeholder = productAmount ? `${productAmount} шт.` : 'шт.';

                // Store warehouse info with the product field
                const warehouseInfo = document.createElement('div');
                warehouseInfo.className = 'warehouse-info';
                warehouseInfo.innerHTML = `
                    <input type="hidden" class="product-warehouse" data-product-id="${selectedProductId}" 
                           value="${data.id}" data-location="${data.location}" data-name="${data.name}">
                `;
                
                // Remove previous warehouse info if exists
                const existingInfo = selectElement.parentNode.querySelector('.warehouse-info');
                if (existingInfo) {
                    existingInfo.remove();
                }
                
                selectElement.parentNode.appendChild(warehouseInfo);

                // Update the warehouses display
                updateWarehousesDisplay();
            }
        })
        .catch(error => console.error(error));
}

function updateWarehousesDisplay() {
    const warehouseInputs = document.querySelectorAll('.product-warehouse');
    const uniqueWarehouses = new Map();
    const warehousesDisplay = document.getElementById('warehouses-display');
    
    // Clear previous display
    warehousesDisplay.innerHTML = '';
    
    // Collect unique warehouses
    warehouseInputs.forEach(input => {
        const warehouseId = input.value;
        if (!uniqueWarehouses.has(warehouseId)) {
            uniqueWarehouses.set(warehouseId, {
                id: warehouseId,
                name: input.dataset.name,
                location: input.dataset.location
            });
        }
    });

    // Update hidden field with comma-separated IDs
    document.getElementById('warehouse_id').value = Array.from(uniqueWarehouses.keys()).join(',');

    // Create display rows for each warehouse
    uniqueWarehouses.forEach((warehouse, id) => {
        const warehouseRow = document.createElement('div');
        warehouseRow.className = 'warehouse-row';
        warehouseRow.innerHTML = `
            <input type="text" value="${warehouse.name}" readonly class="warehouse-name">
            <input type="text" value="${warehouse.location}" readonly class="warehouse-location">
        `;
        warehousesDisplay.appendChild(warehouseRow);
    });

    // Update map with first warehouse location if available
    if (uniqueWarehouses.size > 0) {
        const firstWarehouse = uniqueWarehouses.values().next().value;
        triggerGeocodeAndDisplayMap(firstWarehouse.location);
    }
}

        function triggerGeocodeAndDisplayMap(address) {
            if (address) {
                geocoder.geocode({ address: address }, function (results, status) {
                    if (status === 'OK' && results[0]) {
                        const location = results[0].geometry.location;
                        mk1.setPosition(location);
                        map.panTo(location);
                        calculateAndDisplayRoute();
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', function () {
            handleProductChange(1);
        });


function calculateTotalWeight() {
    let totalWeight = 0;
    const amountInputs = document.getElementsByName('amount[]');
    const weightInputs = document.querySelectorAll('.options option:checked');

    for (let i = 0; i < amountInputs.length; i++) {
        const amount = parseInt(amountInputs[i].value);

        const weightOption = weightInputs[i];
        if (!weightOption) continue;
        let weightText = weightOption.innerText;
        weightText = weightText.replace('(', ''); 
        weightText = weightText.replace(' кг)', ''); 
        const words = weightText.trim().split(' ');

        let weight;
        try {
          weight = parseFloat(words[words.length - 1]);
        } catch (error) {
          weight = undefined;
        }

        if (!isNaN(amount) && !isNaN(weight)) {
            totalWeight += amount * weight;
        }
    }
    console.log(totalWeight);
    return totalWeight;
}


document.getElementById('start_input').addEventListener('input', function () {
    if (this.value.trim() !== '') {
        calculateAndDisplayRoute();
    }
});

document.getElementById('end_input').addEventListener('input', function () {
    if (this.value.trim() !== '') {
        calculateAndDisplayRoute();
    }
});

const dateTimeInput = document.getElementById('planned_date');

document.getElementById('planned_date').addEventListener('change', function() {
    console.log('Selected date/time:');
    if (directionsRenderer.getDirections()) {
        const route = directionsRenderer.getDirections().routes[0];
        let totalDuration = 0;
        route.legs.forEach(leg => {
            totalDuration += leg.duration.value;
        });
        updateEstimatedEndTime(totalDuration);
    }
});

function findOptimalWarehouseOrder(warehouses, startLocation) {
    // Simple approach: sort by distance from start location
    // For a more robust solution, you might want to implement a proper TSP algorithm
    return warehouses.sort((a, b) => {
        const distA = google.maps.geometry.spherical.computeDistanceBetween(
            startLocation, 
            new google.maps.LatLng(a.lat, a.lng)
        );
        const distB = google.maps.geometry.spherical.computeDistanceBetween(
            startLocation, 
            new google.maps.LatLng(b.lat, b.lng)
        );
        return distA - distB;
    });
}

// Modified calculateAndDisplayRoute function
function calculateAndDisplayRoute() {
    const startLocation = mk1.getPosition();
    if (!startLocation) return;

    // Get all warehouse locations from hidden inputs
    const warehouseInputs = document.querySelectorAll('.product-warehouse');
    const uniqueWarehouses = new Map();
    
    warehouseInputs.forEach(input => {
        const location = input.dataset.location;
        if (location && !uniqueWarehouses.has(input.value)) {
            // Geocode warehouse locations if not already done
            geocoder.geocode({ address: location }, (results, status) => {
                if (status === 'OK' && results[0]) {
                    uniqueWarehouses.set(input.value, {
                        id: input.value,
                        name: input.dataset.name,
                        location: results[0].geometry.location,
                        lat: results[0].geometry.location.lat(),
                        lng: results[0].geometry.location.lng()
                    });
                    
                    // When all warehouses are geocoded, proceed with route calculation
                    if (uniqueWarehouses.size === warehouseInputs.length) {
                        calculateFullRoute(Array.from(uniqueWarehouses.values()), startLocation);
                    }
                }
            });
        }
    });

    // If no warehouses (shouldn't happen), just calculate with destinations
    if (uniqueWarehouses.size === 0) {
        calculateFullRoute([], startLocation);
    }
}

function calculateFullRoute(warehouses, startLocation) {
    // Collect all destination positions
    const destinations = [];
    for (let i = 0; i < destinationMarkers.length; i++) {
        const position = destinationMarkers[i].getPosition();
        if (position) {
            destinations.push({
                position: position,
                id: i
            });
        }
    }

    // If no destinations, just show warehouse locations
    if (destinations.length === 0) {
        displayWarehouseMarkers(warehouses);
        return;
    }

    // Determine optimal warehouse order
    const optimalWarehouses = findOptimalWarehouseOrder(warehouses, startLocation);
    
    // Prepare waypoints - all warehouses except first (start) and all destinations except last
    const waypoints = [];
    
    // Add other warehouses as waypoints
    if (optimalWarehouses.length > 1) {
        for (let i = 1; i < optimalWarehouses.length; i++) {
            waypoints.push({
                location: optimalWarehouses[i].location,
                stopover: true
            });
        }
    }

    destinations.sort((a, b) => {
        const distA = google.maps.geometry.spherical.computeDistanceBetween(startLocation, a.position);
        const distB = google.maps.geometry.spherical.computeDistanceBetween(startLocation, b.position);
        return distA - distB;
    });
    
    // Add all destinations except last as waypoints
    if (destinations.length > 1) {
        for (let i = 0; i < destinations.length - 1; i++) {
            waypoints.push({
                location: destinations[i].position,
                stopover: true
            });
        }
    }

    // Final destination is last delivery point
    const finalDestination = destinations[destinations.length - 1].position;

    const route = {
        origin: startLocation,
        destination: finalDestination,
        waypoints: waypoints,
        travelMode: 'DRIVING',
        optimizeWaypoints: true, // Let Google optimize the order of waypoints
        provideRouteAlternatives: false
    };

    directionsService.route(route, function(response, status) {
        if (status !== 'OK') {
            console.error('Directions request failed:', status);
            document.getElementById('msg').innerHTML = 'Помилка маршруту';
            document.getElementById('time').innerHTML = '--';
            return;
        }

        directionsRenderer.setDirections(response);
        updateRouteInfo(response);
    });
}

function displayWarehouseMarkers(warehouses) {
    // Clear existing markers
    directionsRenderer.setMap(null);
    destinationMarkers.forEach(marker => marker.setMap(null));
    destinationMarkers = [];
    
    // Show warehouse markers (all green dots)
    warehouses.forEach((warehouse, index) => {
        const marker = new google.maps.Marker({
            position: warehouse.location,
            map: map,
            icon: {
                path: google.maps.SymbolPath.CIRCLE,
                scale: 8,
                fillColor: '#224F55',
                fillOpacity: 1,
                strokeWeight: 2,
                strokeColor: '#FFFFFF'
            },
            title: warehouse.name,
            zIndex: google.maps.Marker.MAX_ZINDEX
        });
        
        // First warehouse is already shown as mk1
        destinationMarkers.push(marker);
    });
    
    // Center map on all points
    const bounds = new google.maps.LatLngBounds();
    warehouses.forEach(warehouse => bounds.extend(warehouse.location));
    map.fitBounds(bounds);
}

function formatDuration(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    
    let result = '';
    if (hours > 0) result += hours + ' год. ';
    result += minutes + ' хв.';
    return result;
}

function updateEstimatedEndTime(durationSeconds) {
    const startDateInput = document.getElementById('planned_date');
    const estimatedEndInput = document.getElementById('estimated-end');
    const estimatedDateInput = document.getElementById('estimated_date');
    
    if (!startDateInput.value) {
        estimatedEndInput.value = 'Вкажіть дату початку';
        estimatedDateInput.value = '';
        return;
    }
    
    const startDate = new Date(startDateInput.value);
    const endDate = new Date(startDate.getTime() + durationSeconds * 1000);
    
    // Format for human-readable display (estimated-end)
    const options = {
        year: 'numeric',
        month: 'long',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit'
    };
    estimatedEndInput.value = endDate.toLocaleDateString('uk-UA', options);
    
    // Format for datetime-local input (estimated_date)
    const isoString = endDate.toISOString();
    estimatedDateInput.value = isoString.substring(0, isoString.length - 1); // Remove 'Z' at the end
}

function updateRouteInfo(response) {
    const route = response.routes[0];
    let totalDistance = 0;
    let totalDuration = 0;
    
    route.legs.forEach(leg => {
        totalDistance += leg.distance.value;
        totalDuration += leg.duration.value;
    });

    routeDuration = totalDuration;

    // Update UI
    mapInfo = document.getElementById('map_info');
    mapInfo.style.display = 'flex';
    document.getElementById('msg').innerHTML = (totalDistance / 1000).toFixed(1) + ' км';
    document.getElementById('time').innerHTML = formatDuration(totalDuration);

    // Update estimated end time
    updateEstimatedEndTime(totalDuration);

    // Calculate vehicle and fuel costs
    const warehouseId = document.getElementById("warehouse_id").value;
    const totalWeight = calculateTotalWeight();
    
    if (warehouseId && totalWeight) {
        fetch(`/api/vehicle/${warehouseId}`)
            .then(response => response.json())
            .then(data => {
                if (Array.isArray(data)) {
                    const suitableVehicles = data.filter(vehicle => vehicle.capacity >= totalWeight);
                    console.log(suitableVehicles)
                    if (suitableVehicles.length > 0) {
                        const vehicleWithLeastFuel = suitableVehicles.reduce((prev, curr) => {
                            return parseFloat(prev.fuel_amount) < parseFloat(curr.fuel_amount) ? prev : curr;
                        });
                        
                        document.getElementById('car').innerHTML = vehicleWithLeastFuel.name;
                        document.getElementById('vehicle_name').value = vehicleWithLeastFuel.name;
                        document.getElementById('vehicle_capacity').value = vehicleWithLeastFuel.capacity;
                        document.getElementById('vehicle_fuel_amount').value = vehicleWithLeastFuel.fuel_amount;
                        
                        const fuelAmount = parseFloat(vehicleWithLeastFuel.fuel_amount) * 55 / 100;
                        const distanceKm = totalDistance / 1000;
                        console.log(distanceKm)
                        const totalFuelCost = fuelAmount * distanceKm;
                        document.getElementById('fuel').innerHTML = totalFuelCost.toFixed(2) + ' ₴';
                    } else {
                        document.getElementById('car').innerHTML = 'Немає підходящого транспорту';
                        document.getElementById('fuel').innerHTML = '--';
                    }
                }
            })
            .catch(error => {
                console.error('Error fetching vehicles:', error);
                document.getElementById('car').innerHTML = 'Помилка завантаження';
                document.getElementById('fuel').innerHTML = '--';
            });
    }
}

// function calculateAndDisplayRoute() {
//     const startLocation = mk1.getPosition();
//     const endLocation = mk2.getPosition();
//     const warehouseId = document.getElementById("warehouse_id").value;
//     const totalWeight = calculateTotalWeight();

//     if (!startLocation || !endLocation) return;

//     const route = {
//         origin: startLocation,
//         destination: endLocation,
//         travelMode: 'DRIVING'
//     };

//     directionsService.route(route, function (response, status) {
//         if (status !== 'OK') {
//             return;
//         } else {
//             directionsRenderer.setDirections(response);
//             const directionsData = response.routes[0].legs[0];
//             if (!directionsData) {
//                 window.alert('Directions request failed');
//                 return;
//             } else {
//                 mapInfo = document.getElementById('map_info');
//                 mapInfo.style.display = 'flex';
//                 document.getElementById('msg').innerHTML = directionsData.distance.text;
//                 document.getElementById('time').innerHTML = directionsData.duration.text;

//                 fetch(`/api/vehicle/${warehouseId}`)
//                     .then(response => response.json())
//                     .then(data => {
//                         if (Array.isArray(data)) {
//                             const suitableVehicles = data.filter(vehicle => vehicle.capacity >= totalWeight);

//                             if (suitableVehicles.length > 0) {
//                                 const vehicleWithLeastFuel = suitableVehicles.reduce((previous, current) => {
//                                     return parseFloat(previous.fuel_amount) < parseFloat(current.fuel_amount) ? previous : current;
//                                 });

//                                 document.getElementById('car').innerHTML = vehicleWithLeastFuel.name;
//                                 document.getElementById('vehicle_name').value = vehicleWithLeastFuel.name;
//                                 document.getElementById('vehicle_capacity').value = vehicleWithLeastFuel.capacity;
//                                 document.getElementById('vehicle_fuel_amount').value = vehicleWithLeastFuel.fuel_amount;
//                                 const fuelAmount = parseFloat(vehicleWithLeastFuel.fuel_amount) * 55 / 100;
//                                 const distance = parseFloat(directionsData.distance.value) / 1000;
//                                 const totalFuelCost = fuelAmount * distance;
//                                 document.getElementById('fuel').innerHTML = totalFuelCost.toFixed(2) + ' ₴';
//                             } else {
//                                 console.warn('No suitable vehicles found for the given total weight.');
//                             }
//                         } else {
//                             console.warn('API response for vehicles might be incorrect. Expected an array.');
//                         }
//                     })
//                     .catch(error => console.error('Error fetching vehicles:', error));
//             }
//         }
//     });
// }
</script>

</body>
</html>
